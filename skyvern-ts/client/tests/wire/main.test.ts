// This file was auto-generated by Fern from our API Definition.

import * as Skyvern from "../../src/api/index";
import { SkyvernClient } from "../../src/Client";
import { mockServerPool } from "../mock-server/MockServerPool";

describe("SkyvernClient", () => {
    test("run_task (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { prompt: "Find the top 3 posts on Hacker News." };
        const rawResponseBody = {
            run_id: "tsk_123",
            status: "created",
            output: { key: "value" },
            downloaded_files: [
                { url: "url", checksum: "checksum", filename: "filename", modified_at: "2024-01-15T09:30:00Z" },
            ],
            recording_url: "recording_url",
            screenshot_urls: ["screenshot_urls"],
            failure_reason: "failure_reason",
            created_at: "2025-01-01T00:00:00Z",
            modified_at: "2025-01-01T00:05:00Z",
            queued_at: "2024-01-15T09:30:00Z",
            started_at: "2024-01-15T09:30:00Z",
            finished_at: "2024-01-15T09:30:00Z",
            app_url: "app_url",
            browser_session_id: "browser_session_id",
            max_screenshot_scrolls: 1,
            script_run: { ai_fallback_triggered: true },
            errors: [{ key: "value" }],
            run_request: {
                prompt: "Find the top 3 posts on Hacker News.",
                url: "url",
                engine: "skyvern-1.0",
                title: "title",
                proxy_location: "RESIDENTIAL",
                data_extraction_schema: { key: "value" },
                error_code_mapping: { key: "value" },
                max_steps: 1,
                webhook_url: "webhook_url",
                totp_identifier: "totp_identifier",
                totp_url: "totp_url",
                browser_session_id: "browser_session_id",
                model: { key: "value" },
                extra_http_headers: { key: "value" },
                publish_workflow: true,
                include_action_history_in_verification: true,
                max_screenshot_scrolls: 1,
                browser_address: "browser_address",
            },
        };
        server
            .mockEndpoint()
            .post("/v1/run/tasks")
            .header("x-user-agent", "x-user-agent")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.runTask({
            "x-user-agent": "x-user-agent",
            body: {
                prompt: "Find the top 3 posts on Hacker News.",
            },
        });
        expect(response).toEqual({
            run_id: "tsk_123",
            status: "created",
            output: {
                key: "value",
            },
            downloaded_files: [
                {
                    url: "url",
                    checksum: "checksum",
                    filename: "filename",
                    modified_at: "2024-01-15T09:30:00Z",
                },
            ],
            recording_url: "recording_url",
            screenshot_urls: ["screenshot_urls"],
            failure_reason: "failure_reason",
            created_at: "2025-01-01T00:00:00Z",
            modified_at: "2025-01-01T00:05:00Z",
            queued_at: "2024-01-15T09:30:00Z",
            started_at: "2024-01-15T09:30:00Z",
            finished_at: "2024-01-15T09:30:00Z",
            app_url: "app_url",
            browser_session_id: "browser_session_id",
            max_screenshot_scrolls: 1,
            script_run: {
                ai_fallback_triggered: true,
            },
            errors: [
                {
                    key: "value",
                },
            ],
            run_request: {
                prompt: "Find the top 3 posts on Hacker News.",
                url: "url",
                engine: "skyvern-1.0",
                title: "title",
                proxy_location: "RESIDENTIAL",
                data_extraction_schema: {
                    key: "value",
                },
                error_code_mapping: {
                    key: "value",
                },
                max_steps: 1,
                webhook_url: "webhook_url",
                totp_identifier: "totp_identifier",
                totp_url: "totp_url",
                browser_session_id: "browser_session_id",
                model: {
                    key: "value",
                },
                extra_http_headers: {
                    key: "value",
                },
                publish_workflow: true,
                include_action_history_in_verification: true,
                max_screenshot_scrolls: 1,
                browser_address: "browser_address",
            },
        });
    });

    test("run_task (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { prompt: "prompt" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/run/tasks")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.runTask({
                body: {
                    prompt: "prompt",
                },
            });
        }).rejects.toThrow(Skyvern.BadRequestError);
    });

    test("run_task (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { prompt: "prompt" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/run/tasks")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.runTask({
                body: {
                    prompt: "prompt",
                },
            });
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("run_workflow (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { workflow_id: "wpid_123" };
        const rawResponseBody = {
            run_id: "tsk_123",
            status: "created",
            output: { key: "value" },
            downloaded_files: [
                { url: "url", checksum: "checksum", filename: "filename", modified_at: "2024-01-15T09:30:00Z" },
            ],
            recording_url: "recording_url",
            screenshot_urls: ["screenshot_urls"],
            failure_reason: "failure_reason",
            created_at: "2025-01-01T00:00:00Z",
            modified_at: "2025-01-01T00:05:00Z",
            queued_at: "2024-01-15T09:30:00Z",
            started_at: "2024-01-15T09:30:00Z",
            finished_at: "2024-01-15T09:30:00Z",
            app_url: "app_url",
            browser_session_id: "browser_session_id",
            max_screenshot_scrolls: 1,
            script_run: { ai_fallback_triggered: true },
            errors: [{ key: "value" }],
            run_with: "run_with",
            ai_fallback: true,
            run_request: {
                workflow_id: "wpid_123",
                parameters: { key: "value" },
                title: "title",
                proxy_location: "RESIDENTIAL",
                webhook_url: "webhook_url",
                totp_url: "totp_url",
                totp_identifier: "totp_identifier",
                browser_session_id: "browser_session_id",
                max_screenshot_scrolls: 1,
                extra_http_headers: { key: "value" },
                browser_address: "browser_address",
                ai_fallback: true,
                run_with: "run_with",
            },
        };
        server
            .mockEndpoint()
            .post("/v1/run/workflows")
            .header("x-max-steps-override", "1")
            .header("x-user-agent", "x-user-agent")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.runWorkflow({
            "x-max-steps-override": 1,
            "x-user-agent": "x-user-agent",
            template: true,
            body: {
                workflow_id: "wpid_123",
            },
        });
        expect(response).toEqual({
            run_id: "tsk_123",
            status: "created",
            output: {
                key: "value",
            },
            downloaded_files: [
                {
                    url: "url",
                    checksum: "checksum",
                    filename: "filename",
                    modified_at: "2024-01-15T09:30:00Z",
                },
            ],
            recording_url: "recording_url",
            screenshot_urls: ["screenshot_urls"],
            failure_reason: "failure_reason",
            created_at: "2025-01-01T00:00:00Z",
            modified_at: "2025-01-01T00:05:00Z",
            queued_at: "2024-01-15T09:30:00Z",
            started_at: "2024-01-15T09:30:00Z",
            finished_at: "2024-01-15T09:30:00Z",
            app_url: "app_url",
            browser_session_id: "browser_session_id",
            max_screenshot_scrolls: 1,
            script_run: {
                ai_fallback_triggered: true,
            },
            errors: [
                {
                    key: "value",
                },
            ],
            run_with: "run_with",
            ai_fallback: true,
            run_request: {
                workflow_id: "wpid_123",
                parameters: {
                    key: "value",
                },
                title: "title",
                proxy_location: "RESIDENTIAL",
                webhook_url: "webhook_url",
                totp_url: "totp_url",
                totp_identifier: "totp_identifier",
                browser_session_id: "browser_session_id",
                max_screenshot_scrolls: 1,
                extra_http_headers: {
                    key: "value",
                },
                browser_address: "browser_address",
                ai_fallback: true,
                run_with: "run_with",
            },
        });
    });

    test("run_workflow (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { workflow_id: "workflow_id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/run/workflows")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.runWorkflow({
                body: {
                    workflow_id: "workflow_id",
                },
            });
        }).rejects.toThrow(Skyvern.BadRequestError);
    });

    test("run_workflow (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { workflow_id: "workflow_id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/run/workflows")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.runWorkflow({
                body: {
                    workflow_id: "workflow_id",
                },
            });
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("get_run (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            run_type: "task_v1",
            run_id: "tsk_123",
            status: "created",
            output: { key: "value" },
            downloaded_files: [
                { url: "url", checksum: "checksum", filename: "filename", modified_at: "2024-01-15T09:30:00Z" },
            ],
            recording_url: "recording_url",
            screenshot_urls: ["screenshot_urls"],
            failure_reason: "failure_reason",
            created_at: "2025-01-01T00:00:00Z",
            modified_at: "2025-01-01T00:05:00Z",
            queued_at: "2024-01-15T09:30:00Z",
            started_at: "2024-01-15T09:30:00Z",
            finished_at: "2024-01-15T09:30:00Z",
            app_url: "app_url",
            browser_session_id: "browser_session_id",
            max_screenshot_scrolls: 1,
            script_run: { ai_fallback_triggered: true },
            errors: [{ key: "value" }],
            run_request: {
                prompt: "Find the top 3 posts on Hacker News.",
                url: "url",
                engine: "skyvern-1.0",
                title: "title",
                proxy_location: "RESIDENTIAL",
                data_extraction_schema: { key: "value" },
                error_code_mapping: { key: "value" },
                max_steps: 1,
                webhook_url: "webhook_url",
                totp_identifier: "totp_identifier",
                totp_url: "totp_url",
                browser_session_id: "browser_session_id",
                model: { key: "value" },
                extra_http_headers: { key: "value" },
                publish_workflow: true,
                include_action_history_in_verification: true,
                max_screenshot_scrolls: 1,
                browser_address: "browser_address",
            },
        };
        server.mockEndpoint().get("/v1/runs/tsk_123").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getRun("tsk_123");
        expect(response).toEqual({
            run_type: "task_v1",
            run_id: "tsk_123",
            status: "created",
            output: {
                key: "value",
            },
            downloaded_files: [
                {
                    url: "url",
                    checksum: "checksum",
                    filename: "filename",
                    modified_at: "2024-01-15T09:30:00Z",
                },
            ],
            recording_url: "recording_url",
            screenshot_urls: ["screenshot_urls"],
            failure_reason: "failure_reason",
            created_at: "2025-01-01T00:00:00Z",
            modified_at: "2025-01-01T00:05:00Z",
            queued_at: "2024-01-15T09:30:00Z",
            started_at: "2024-01-15T09:30:00Z",
            finished_at: "2024-01-15T09:30:00Z",
            app_url: "app_url",
            browser_session_id: "browser_session_id",
            max_screenshot_scrolls: 1,
            script_run: {
                ai_fallback_triggered: true,
            },
            errors: [
                {
                    key: "value",
                },
            ],
            run_request: {
                prompt: "Find the top 3 posts on Hacker News.",
                url: "url",
                engine: "skyvern-1.0",
                title: "title",
                proxy_location: "RESIDENTIAL",
                data_extraction_schema: {
                    key: "value",
                },
                error_code_mapping: {
                    key: "value",
                },
                max_steps: 1,
                webhook_url: "webhook_url",
                totp_identifier: "totp_identifier",
                totp_url: "totp_url",
                browser_session_id: "browser_session_id",
                model: {
                    key: "value",
                },
                extra_http_headers: {
                    key: "value",
                },
                publish_workflow: true,
                include_action_history_in_verification: true,
                max_screenshot_scrolls: 1,
                browser_address: "browser_address",
            },
        });
    });

    test("get_run (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/v1/runs/run_id").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.getRun("run_id");
        }).rejects.toThrow(Skyvern.NotFoundError);
    });

    test("get_run (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/v1/runs/run_id").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.getRun("run_id");
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("cancel_run (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/runs/run_id/cancel")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.cancelRun("run_id");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("cancel_run (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/runs/run_id/cancel")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.cancelRun("run_id");
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("get_workflows (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                workflow_id: "workflow_id",
                organization_id: "organization_id",
                title: "title",
                workflow_permanent_id: "workflow_permanent_id",
                version: 1,
                is_saved_task: true,
                description: "description",
                workflow_definition: {
                    parameters: [
                        {
                            parameter_type: "aws_secret",
                            key: "key",
                            aws_secret_parameter_id: "aws_secret_parameter_id",
                            workflow_id: "workflow_id",
                            aws_key: "aws_key",
                            created_at: "2024-01-15T09:30:00Z",
                            modified_at: "2024-01-15T09:30:00Z",
                        },
                    ],
                    blocks: [
                        {
                            block_type: "action",
                            label: "label",
                            output_parameter: {
                                key: "key",
                                output_parameter_id: "output_parameter_id",
                                workflow_id: "workflow_id",
                                created_at: "2024-01-15T09:30:00Z",
                                modified_at: "2024-01-15T09:30:00Z",
                            },
                        },
                    ],
                },
                proxy_location: "RESIDENTIAL",
                webhook_callback_url: "webhook_callback_url",
                totp_verification_url: "totp_verification_url",
                totp_identifier: "totp_identifier",
                persist_browser_session: true,
                model: { key: "value" },
                status: "published",
                max_screenshot_scrolls: 1,
                extra_http_headers: { key: "value" },
                run_with: "run_with",
                ai_fallback: true,
                cache_key: "cache_key",
                run_sequentially: true,
                sequential_key: "sequential_key",
                created_at: "2024-01-15T09:30:00Z",
                modified_at: "2024-01-15T09:30:00Z",
                deleted_at: "2024-01-15T09:30:00Z",
            },
        ];
        server.mockEndpoint().get("/v1/workflows").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getWorkflows({
            page: 1,
            page_size: 1,
            only_saved_tasks: true,
            only_workflows: true,
            search_key: "search_key",
            title: "title",
            template: true,
        });
        expect(response).toEqual([
            {
                workflow_id: "workflow_id",
                organization_id: "organization_id",
                title: "title",
                workflow_permanent_id: "workflow_permanent_id",
                version: 1,
                is_saved_task: true,
                description: "description",
                workflow_definition: {
                    parameters: [
                        {
                            parameter_type: "aws_secret",
                            key: "key",
                            aws_secret_parameter_id: "aws_secret_parameter_id",
                            workflow_id: "workflow_id",
                            aws_key: "aws_key",
                            created_at: "2024-01-15T09:30:00Z",
                            modified_at: "2024-01-15T09:30:00Z",
                        },
                    ],
                    blocks: [
                        {
                            block_type: "action",
                            label: "label",
                            output_parameter: {
                                key: "key",
                                output_parameter_id: "output_parameter_id",
                                workflow_id: "workflow_id",
                                created_at: "2024-01-15T09:30:00Z",
                                modified_at: "2024-01-15T09:30:00Z",
                            },
                        },
                    ],
                },
                proxy_location: "RESIDENTIAL",
                webhook_callback_url: "webhook_callback_url",
                totp_verification_url: "totp_verification_url",
                totp_identifier: "totp_identifier",
                persist_browser_session: true,
                model: {
                    key: "value",
                },
                status: "published",
                max_screenshot_scrolls: 1,
                extra_http_headers: {
                    key: "value",
                },
                run_with: "run_with",
                ai_fallback: true,
                cache_key: "cache_key",
                run_sequentially: true,
                sequential_key: "sequential_key",
                created_at: "2024-01-15T09:30:00Z",
                modified_at: "2024-01-15T09:30:00Z",
                deleted_at: "2024-01-15T09:30:00Z",
            },
        ]);
    });

    test("get_workflows (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/v1/workflows").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.getWorkflows();
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("create_workflow (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            workflow_id: "workflow_id",
            organization_id: "organization_id",
            title: "title",
            workflow_permanent_id: "workflow_permanent_id",
            version: 1,
            is_saved_task: true,
            description: "description",
            workflow_definition: {
                parameters: [
                    {
                        parameter_type: "aws_secret",
                        key: "key",
                        aws_secret_parameter_id: "aws_secret_parameter_id",
                        workflow_id: "workflow_id",
                        aws_key: "aws_key",
                        created_at: "2024-01-15T09:30:00Z",
                        modified_at: "2024-01-15T09:30:00Z",
                    },
                ],
                blocks: [
                    {
                        block_type: "action",
                        label: "label",
                        output_parameter: {
                            key: "key",
                            output_parameter_id: "output_parameter_id",
                            workflow_id: "workflow_id",
                            created_at: "2024-01-15T09:30:00Z",
                            modified_at: "2024-01-15T09:30:00Z",
                        },
                    },
                ],
            },
            proxy_location: "RESIDENTIAL",
            webhook_callback_url: "webhook_callback_url",
            totp_verification_url: "totp_verification_url",
            totp_identifier: "totp_identifier",
            persist_browser_session: true,
            model: { key: "value" },
            status: "published",
            max_screenshot_scrolls: 1,
            extra_http_headers: { key: "value" },
            run_with: "run_with",
            ai_fallback: true,
            cache_key: "cache_key",
            run_sequentially: true,
            sequential_key: "sequential_key",
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
            deleted_at: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .post("/v1/workflows")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.createWorkflow({});
        expect(response).toEqual({
            workflow_id: "workflow_id",
            organization_id: "organization_id",
            title: "title",
            workflow_permanent_id: "workflow_permanent_id",
            version: 1,
            is_saved_task: true,
            description: "description",
            workflow_definition: {
                parameters: [
                    {
                        parameter_type: "aws_secret",
                        key: "key",
                        aws_secret_parameter_id: "aws_secret_parameter_id",
                        workflow_id: "workflow_id",
                        aws_key: "aws_key",
                        created_at: "2024-01-15T09:30:00Z",
                        modified_at: "2024-01-15T09:30:00Z",
                    },
                ],
                blocks: [
                    {
                        block_type: "action",
                        label: "label",
                        output_parameter: {
                            key: "key",
                            output_parameter_id: "output_parameter_id",
                            workflow_id: "workflow_id",
                            created_at: "2024-01-15T09:30:00Z",
                            modified_at: "2024-01-15T09:30:00Z",
                        },
                    },
                ],
            },
            proxy_location: "RESIDENTIAL",
            webhook_callback_url: "webhook_callback_url",
            totp_verification_url: "totp_verification_url",
            totp_identifier: "totp_identifier",
            persist_browser_session: true,
            model: {
                key: "value",
            },
            status: "published",
            max_screenshot_scrolls: 1,
            extra_http_headers: {
                key: "value",
            },
            run_with: "run_with",
            ai_fallback: true,
            cache_key: "cache_key",
            run_sequentially: true,
            sequential_key: "sequential_key",
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
            deleted_at: "2024-01-15T09:30:00Z",
        });
    });

    test("create_workflow (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/workflows")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.createWorkflow({});
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("update_workflow (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            workflow_id: "workflow_id",
            organization_id: "organization_id",
            title: "title",
            workflow_permanent_id: "workflow_permanent_id",
            version: 1,
            is_saved_task: true,
            description: "description",
            workflow_definition: {
                parameters: [
                    {
                        parameter_type: "aws_secret",
                        key: "key",
                        aws_secret_parameter_id: "aws_secret_parameter_id",
                        workflow_id: "workflow_id",
                        aws_key: "aws_key",
                        created_at: "2024-01-15T09:30:00Z",
                        modified_at: "2024-01-15T09:30:00Z",
                    },
                ],
                blocks: [
                    {
                        block_type: "action",
                        label: "label",
                        output_parameter: {
                            key: "key",
                            output_parameter_id: "output_parameter_id",
                            workflow_id: "workflow_id",
                            created_at: "2024-01-15T09:30:00Z",
                            modified_at: "2024-01-15T09:30:00Z",
                        },
                    },
                ],
            },
            proxy_location: "RESIDENTIAL",
            webhook_callback_url: "webhook_callback_url",
            totp_verification_url: "totp_verification_url",
            totp_identifier: "totp_identifier",
            persist_browser_session: true,
            model: { key: "value" },
            status: "published",
            max_screenshot_scrolls: 1,
            extra_http_headers: { key: "value" },
            run_with: "run_with",
            ai_fallback: true,
            cache_key: "cache_key",
            run_sequentially: true,
            sequential_key: "sequential_key",
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
            deleted_at: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .post("/v1/workflows/wpid_123")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.updateWorkflow("wpid_123", {});
        expect(response).toEqual({
            workflow_id: "workflow_id",
            organization_id: "organization_id",
            title: "title",
            workflow_permanent_id: "workflow_permanent_id",
            version: 1,
            is_saved_task: true,
            description: "description",
            workflow_definition: {
                parameters: [
                    {
                        parameter_type: "aws_secret",
                        key: "key",
                        aws_secret_parameter_id: "aws_secret_parameter_id",
                        workflow_id: "workflow_id",
                        aws_key: "aws_key",
                        created_at: "2024-01-15T09:30:00Z",
                        modified_at: "2024-01-15T09:30:00Z",
                    },
                ],
                blocks: [
                    {
                        block_type: "action",
                        label: "label",
                        output_parameter: {
                            key: "key",
                            output_parameter_id: "output_parameter_id",
                            workflow_id: "workflow_id",
                            created_at: "2024-01-15T09:30:00Z",
                            modified_at: "2024-01-15T09:30:00Z",
                        },
                    },
                ],
            },
            proxy_location: "RESIDENTIAL",
            webhook_callback_url: "webhook_callback_url",
            totp_verification_url: "totp_verification_url",
            totp_identifier: "totp_identifier",
            persist_browser_session: true,
            model: {
                key: "value",
            },
            status: "published",
            max_screenshot_scrolls: 1,
            extra_http_headers: {
                key: "value",
            },
            run_with: "run_with",
            ai_fallback: true,
            cache_key: "cache_key",
            run_sequentially: true,
            sequential_key: "sequential_key",
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
            deleted_at: "2024-01-15T09:30:00Z",
        });
    });

    test("update_workflow (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/workflows/workflow_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.updateWorkflow("workflow_id", {});
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("delete_workflow (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/workflows/wpid_123/delete")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.deleteWorkflow("wpid_123");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("delete_workflow (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/workflows/workflow_id/delete")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.deleteWorkflow("workflow_id");
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("get_artifact (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            created_at: "2023-01-01T00:00:00Z",
            modified_at: "2023-01-01T00:00:00Z",
            artifact_id: "artifact_id",
            artifact_type: "recording",
            uri: "uri",
            task_id: "task_id",
            step_id: "step_id",
            workflow_run_id: "workflow_run_id",
            workflow_run_block_id: "workflow_run_block_id",
            observer_cruise_id: "observer_cruise_id",
            observer_thought_id: "observer_thought_id",
            ai_suggestion_id: "ai_suggestion_id",
            signed_url: "signed_url",
            organization_id: "organization_id",
        };
        server
            .mockEndpoint()
            .get("/v1/artifacts/artifact_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getArtifact("artifact_id");
        expect(response).toEqual({
            created_at: "2023-01-01T00:00:00Z",
            modified_at: "2023-01-01T00:00:00Z",
            artifact_id: "artifact_id",
            artifact_type: "recording",
            uri: "uri",
            task_id: "task_id",
            step_id: "step_id",
            workflow_run_id: "workflow_run_id",
            workflow_run_block_id: "workflow_run_block_id",
            observer_cruise_id: "observer_cruise_id",
            observer_thought_id: "observer_thought_id",
            ai_suggestion_id: "ai_suggestion_id",
            signed_url: "signed_url",
            organization_id: "organization_id",
        });
    });

    test("get_artifact (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/artifacts/artifact_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getArtifact("artifact_id");
        }).rejects.toThrow(Skyvern.NotFoundError);
    });

    test("get_artifact (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/artifacts/artifact_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getArtifact("artifact_id");
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("get_run_artifacts (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                created_at: "2023-01-01T00:00:00Z",
                modified_at: "2023-01-01T00:00:00Z",
                artifact_id: "artifact_id",
                artifact_type: "recording",
                uri: "uri",
                task_id: "task_id",
                step_id: "step_id",
                workflow_run_id: "workflow_run_id",
                workflow_run_block_id: "workflow_run_block_id",
                observer_cruise_id: "observer_cruise_id",
                observer_thought_id: "observer_thought_id",
                ai_suggestion_id: "ai_suggestion_id",
                signed_url: "signed_url",
                organization_id: "organization_id",
            },
        ];
        server
            .mockEndpoint()
            .get("/v1/runs/run_id/artifacts")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getRunArtifacts("run_id");
        expect(response).toEqual([
            {
                created_at: "2023-01-01T00:00:00Z",
                modified_at: "2023-01-01T00:00:00Z",
                artifact_id: "artifact_id",
                artifact_type: "recording",
                uri: "uri",
                task_id: "task_id",
                step_id: "step_id",
                workflow_run_id: "workflow_run_id",
                workflow_run_block_id: "workflow_run_block_id",
                observer_cruise_id: "observer_cruise_id",
                observer_thought_id: "observer_thought_id",
                ai_suggestion_id: "ai_suggestion_id",
                signed_url: "signed_url",
                organization_id: "organization_id",
            },
        ]);
    });

    test("get_run_artifacts (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/runs/run_id/artifacts")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getRunArtifacts("run_id");
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("retry_run_webhook (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/runs/tsk_123/retry_webhook")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.retryRunWebhook("tsk_123");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("retry_run_webhook (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/runs/run_id/retry_webhook")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.retryRunWebhook("run_id");
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("get_run_timeline (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                type: "thought",
                block: {
                    workflow_run_block_id: "workflow_run_block_id",
                    block_workflow_run_id: "block_workflow_run_id",
                    workflow_run_id: "workflow_run_id",
                    organization_id: "organization_id",
                    description: "description",
                    parent_workflow_run_block_id: "parent_workflow_run_block_id",
                    block_type: "task",
                    label: "label",
                    status: "status",
                    output: { key: "value" },
                    continue_on_failure: true,
                    failure_reason: "failure_reason",
                    engine: "skyvern-1.0",
                    task_id: "task_id",
                    url: "url",
                    navigation_goal: "navigation_goal",
                    navigation_payload: { key: "value" },
                    data_extraction_goal: "data_extraction_goal",
                    data_schema: { key: "value" },
                    terminate_criterion: "terminate_criterion",
                    complete_criterion: "complete_criterion",
                    actions: [{ action_type: "click" }],
                    created_at: "2024-01-15T09:30:00Z",
                    modified_at: "2024-01-15T09:30:00Z",
                    include_action_history_in_verification: true,
                    duration: 1.1,
                    loop_values: [],
                    current_value: "current_value",
                    current_index: 1,
                    recipients: ["recipients"],
                    attachments: ["attachments"],
                    subject: "subject",
                    body: "body",
                },
                thought: {
                    thought_id: "thought_id",
                    task_id: "task_id",
                    organization_id: "organization_id",
                    workflow_run_id: "workflow_run_id",
                    workflow_run_block_id: "workflow_run_block_id",
                    workflow_id: "workflow_id",
                    workflow_permanent_id: "workflow_permanent_id",
                    user_input: "user_input",
                    observation: "observation",
                    thought: "thought",
                    answer: "answer",
                    thought_type: "plan",
                    thought_scenario: "generate_plan",
                    output: { key: "value" },
                    input_token_count: 1,
                    output_token_count: 1,
                    reasoning_token_count: 1,
                    cached_token_count: 1,
                    thought_cost: 1.1,
                    created_at: "2024-01-15T09:30:00Z",
                    modified_at: "2024-01-15T09:30:00Z",
                },
                created_at: "2024-01-15T09:30:00Z",
                modified_at: "2024-01-15T09:30:00Z",
            },
        ];
        server
            .mockEndpoint()
            .get("/v1/runs/wr_123/timeline")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getRunTimeline("wr_123");
        expect(response).toEqual([
            {
                type: "thought",
                block: {
                    workflow_run_block_id: "workflow_run_block_id",
                    block_workflow_run_id: "block_workflow_run_id",
                    workflow_run_id: "workflow_run_id",
                    organization_id: "organization_id",
                    description: "description",
                    parent_workflow_run_block_id: "parent_workflow_run_block_id",
                    block_type: "task",
                    label: "label",
                    status: "status",
                    output: {
                        key: "value",
                    },
                    continue_on_failure: true,
                    failure_reason: "failure_reason",
                    engine: "skyvern-1.0",
                    task_id: "task_id",
                    url: "url",
                    navigation_goal: "navigation_goal",
                    navigation_payload: {
                        key: "value",
                    },
                    data_extraction_goal: "data_extraction_goal",
                    data_schema: {
                        key: "value",
                    },
                    terminate_criterion: "terminate_criterion",
                    complete_criterion: "complete_criterion",
                    actions: [
                        {
                            action_type: "click",
                        },
                    ],
                    created_at: "2024-01-15T09:30:00Z",
                    modified_at: "2024-01-15T09:30:00Z",
                    include_action_history_in_verification: true,
                    duration: 1.1,
                    loop_values: [],
                    current_value: "current_value",
                    current_index: 1,
                    recipients: ["recipients"],
                    attachments: ["attachments"],
                    subject: "subject",
                    body: "body",
                },
                thought: {
                    thought_id: "thought_id",
                    task_id: "task_id",
                    organization_id: "organization_id",
                    workflow_run_id: "workflow_run_id",
                    workflow_run_block_id: "workflow_run_block_id",
                    workflow_id: "workflow_id",
                    workflow_permanent_id: "workflow_permanent_id",
                    user_input: "user_input",
                    observation: "observation",
                    thought: "thought",
                    answer: "answer",
                    thought_type: "plan",
                    thought_scenario: "generate_plan",
                    output: {
                        key: "value",
                    },
                    input_token_count: 1,
                    output_token_count: 1,
                    reasoning_token_count: 1,
                    cached_token_count: 1,
                    thought_cost: 1.1,
                    created_at: "2024-01-15T09:30:00Z",
                    modified_at: "2024-01-15T09:30:00Z",
                },
                created_at: "2024-01-15T09:30:00Z",
                modified_at: "2024-01-15T09:30:00Z",
            },
        ]);
    });

    test("get_run_timeline (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/runs/run_id/timeline")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getRunTimeline("run_id");
        }).rejects.toThrow(Skyvern.BadRequestError);
    });

    test("get_run_timeline (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/runs/run_id/timeline")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getRunTimeline("run_id");
        }).rejects.toThrow(Skyvern.NotFoundError);
    });

    test("get_run_timeline (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/runs/run_id/timeline")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getRunTimeline("run_id");
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("get_browser_sessions (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                browser_session_id: "pbs_123456",
                organization_id: "organization_id",
                runnable_type: "runnable_type",
                runnable_id: "runnable_id",
                timeout: 1,
                browser_address: "browser_address",
                app_url: "app_url",
                vnc_streaming_supported: true,
                download_path: "download_path",
                downloaded_files: [{ url: "url" }],
                recordings: [{ url: "url" }],
                started_at: "2024-01-15T09:30:00Z",
                completed_at: "2024-01-15T09:30:00Z",
                created_at: "2024-01-15T09:30:00Z",
                modified_at: "2024-01-15T09:30:00Z",
                deleted_at: "2024-01-15T09:30:00Z",
            },
        ];
        server
            .mockEndpoint()
            .get("/v1/browser_sessions")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getBrowserSessions();
        expect(response).toEqual([
            {
                browser_session_id: "pbs_123456",
                organization_id: "organization_id",
                runnable_type: "runnable_type",
                runnable_id: "runnable_id",
                timeout: 1,
                browser_address: "browser_address",
                app_url: "app_url",
                vnc_streaming_supported: true,
                download_path: "download_path",
                downloaded_files: [
                    {
                        url: "url",
                    },
                ],
                recordings: [
                    {
                        url: "url",
                    },
                ],
                started_at: "2024-01-15T09:30:00Z",
                completed_at: "2024-01-15T09:30:00Z",
                created_at: "2024-01-15T09:30:00Z",
                modified_at: "2024-01-15T09:30:00Z",
                deleted_at: "2024-01-15T09:30:00Z",
            },
        ]);
    });

    test("get_browser_sessions (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/browser_sessions")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getBrowserSessions();
        }).rejects.toThrow(Skyvern.ForbiddenError);
    });

    test("get_browser_sessions (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/browser_sessions")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getBrowserSessions();
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("create_browser_session (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            browser_session_id: "pbs_123456",
            organization_id: "organization_id",
            runnable_type: "runnable_type",
            runnable_id: "runnable_id",
            timeout: 1,
            browser_address: "browser_address",
            app_url: "app_url",
            vnc_streaming_supported: true,
            download_path: "download_path",
            downloaded_files: [
                { url: "url", checksum: "checksum", filename: "filename", modified_at: "2024-01-15T09:30:00Z" },
            ],
            recordings: [
                { url: "url", checksum: "checksum", filename: "filename", modified_at: "2024-01-15T09:30:00Z" },
            ],
            started_at: "2024-01-15T09:30:00Z",
            completed_at: "2024-01-15T09:30:00Z",
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
            deleted_at: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .post("/v1/browser_sessions")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.createBrowserSession();
        expect(response).toEqual({
            browser_session_id: "pbs_123456",
            organization_id: "organization_id",
            runnable_type: "runnable_type",
            runnable_id: "runnable_id",
            timeout: 1,
            browser_address: "browser_address",
            app_url: "app_url",
            vnc_streaming_supported: true,
            download_path: "download_path",
            downloaded_files: [
                {
                    url: "url",
                    checksum: "checksum",
                    filename: "filename",
                    modified_at: "2024-01-15T09:30:00Z",
                },
            ],
            recordings: [
                {
                    url: "url",
                    checksum: "checksum",
                    filename: "filename",
                    modified_at: "2024-01-15T09:30:00Z",
                },
            ],
            started_at: "2024-01-15T09:30:00Z",
            completed_at: "2024-01-15T09:30:00Z",
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
            deleted_at: "2024-01-15T09:30:00Z",
        });
    });

    test("create_browser_session (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/browser_sessions")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.createBrowserSession();
        }).rejects.toThrow(Skyvern.ForbiddenError);
    });

    test("create_browser_session (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/browser_sessions")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.createBrowserSession();
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("close_browser_session (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/browser_sessions/pbs_123456/close")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.closeBrowserSession("pbs_123456");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("close_browser_session (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/browser_sessions/browser_session_id/close")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.closeBrowserSession("browser_session_id");
        }).rejects.toThrow(Skyvern.ForbiddenError);
    });

    test("close_browser_session (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/browser_sessions/browser_session_id/close")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.closeBrowserSession("browser_session_id");
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("get_browser_session (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            browser_session_id: "pbs_123456",
            organization_id: "organization_id",
            runnable_type: "runnable_type",
            runnable_id: "runnable_id",
            timeout: 1,
            browser_address: "browser_address",
            app_url: "app_url",
            vnc_streaming_supported: true,
            download_path: "download_path",
            downloaded_files: [
                { url: "url", checksum: "checksum", filename: "filename", modified_at: "2024-01-15T09:30:00Z" },
            ],
            recordings: [
                { url: "url", checksum: "checksum", filename: "filename", modified_at: "2024-01-15T09:30:00Z" },
            ],
            started_at: "2024-01-15T09:30:00Z",
            completed_at: "2024-01-15T09:30:00Z",
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
            deleted_at: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .get("/v1/browser_sessions/pbs_123456")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getBrowserSession("pbs_123456");
        expect(response).toEqual({
            browser_session_id: "pbs_123456",
            organization_id: "organization_id",
            runnable_type: "runnable_type",
            runnable_id: "runnable_id",
            timeout: 1,
            browser_address: "browser_address",
            app_url: "app_url",
            vnc_streaming_supported: true,
            download_path: "download_path",
            downloaded_files: [
                {
                    url: "url",
                    checksum: "checksum",
                    filename: "filename",
                    modified_at: "2024-01-15T09:30:00Z",
                },
            ],
            recordings: [
                {
                    url: "url",
                    checksum: "checksum",
                    filename: "filename",
                    modified_at: "2024-01-15T09:30:00Z",
                },
            ],
            started_at: "2024-01-15T09:30:00Z",
            completed_at: "2024-01-15T09:30:00Z",
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
            deleted_at: "2024-01-15T09:30:00Z",
        });
    });

    test("get_browser_session (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/browser_sessions/browser_session_id")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getBrowserSession("browser_session_id");
        }).rejects.toThrow(Skyvern.ForbiddenError);
    });

    test("get_browser_session (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/browser_sessions/browser_session_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getBrowserSession("browser_session_id");
        }).rejects.toThrow(Skyvern.NotFoundError);
    });

    test("get_browser_session (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/browser_sessions/browser_session_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getBrowserSession("browser_session_id");
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("send_totp_code (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            totp_identifier: "john.doe@example.com",
            content: "Hello, your verification code is 123456",
        };
        const rawResponseBody = {
            totp_identifier: "john.doe@example.com",
            task_id: "task_id",
            workflow_id: "workflow_id",
            workflow_run_id: "workflow_run_id",
            source: "source",
            content: "Hello, your verification code is 123456",
            expired_at: "2024-01-15T09:30:00Z",
            totp_code_id: "totp_code_id",
            code: "code",
            organization_id: "organization_id",
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
            otp_type: "totp",
        };
        server
            .mockEndpoint()
            .post("/v1/credentials/totp")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.sendTotpCode({
            totp_identifier: "john.doe@example.com",
            content: "Hello, your verification code is 123456",
        });
        expect(response).toEqual({
            totp_identifier: "john.doe@example.com",
            task_id: "task_id",
            workflow_id: "workflow_id",
            workflow_run_id: "workflow_run_id",
            source: "source",
            content: "Hello, your verification code is 123456",
            expired_at: "2024-01-15T09:30:00Z",
            totp_code_id: "totp_code_id",
            code: "code",
            organization_id: "organization_id",
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
            otp_type: "totp",
        });
    });

    test("send_totp_code (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { totp_identifier: "totp_identifier", content: "content" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/credentials/totp")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.sendTotpCode({
                totp_identifier: "totp_identifier",
                content: "content",
            });
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("get_credentials (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                credential_id: "cred_1234567890",
                credential: { username: "user@example.com", totp_type: "authenticator" },
                credential_type: "password",
                name: "Amazon Login",
            },
        ];
        server.mockEndpoint().get("/v1/credentials").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getCredentials({
            page: 1,
            page_size: 10,
        });
        expect(response).toEqual([
            {
                credential_id: "cred_1234567890",
                credential: {
                    username: "user@example.com",
                    totp_type: "authenticator",
                },
                credential_type: "password",
                name: "Amazon Login",
            },
        ]);
    });

    test("get_credentials (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/v1/credentials").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.getCredentials();
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("create_credential (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            name: "My Credential",
            credential_type: "password",
            credential: { password: "securepassword123", username: "user@example.com", totp: "JBSWY3DPEHPK3PXP" },
        };
        const rawResponseBody = {
            credential_id: "cred_1234567890",
            credential: { username: "user@example.com", totp_type: "authenticator" },
            credential_type: "password",
            name: "Amazon Login",
        };
        server
            .mockEndpoint()
            .post("/v1/credentials")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.createCredential({
            name: "My Credential",
            credential_type: "password",
            credential: {
                password: "securepassword123",
                username: "user@example.com",
                totp: "JBSWY3DPEHPK3PXP",
            },
        });
        expect(response).toEqual({
            credential_id: "cred_1234567890",
            credential: {
                username: "user@example.com",
                totp_type: "authenticator",
            },
            credential_type: "password",
            name: "Amazon Login",
        });
    });

    test("create_credential (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            name: "name",
            credential_type: "password",
            credential: { password: "x", username: "x" },
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/credentials")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.createCredential({
                name: "name",
                credential_type: "password",
                credential: {
                    password: "x",
                    username: "x",
                },
            });
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("delete_credential (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        server.mockEndpoint().post("/v1/credentials/cred_1234567890/delete").respondWith().statusCode(200).build();

        const response = await client.deleteCredential("cred_1234567890");
        expect(response).toEqual(undefined);
    });

    test("delete_credential (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/credentials/credential_id/delete")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.deleteCredential("credential_id");
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("get_credential (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            credential_id: "cred_1234567890",
            credential: { username: "user@example.com", totp_type: "authenticator" },
            credential_type: "password",
            name: "Amazon Login",
        };
        server
            .mockEndpoint()
            .get("/v1/credentials/cred_1234567890")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getCredential("cred_1234567890");
        expect(response).toEqual({
            credential_id: "cred_1234567890",
            credential: {
                username: "user@example.com",
                totp_type: "authenticator",
            },
            credential_type: "password",
            name: "Amazon Login",
        });
    });

    test("get_credential (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/credentials/credential_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getCredential("credential_id");
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("login (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { credential_type: "skyvern" };
        const rawResponseBody = {
            run_id: "tsk_123",
            status: "created",
            output: { key: "value" },
            downloaded_files: [
                { url: "url", checksum: "checksum", filename: "filename", modified_at: "2024-01-15T09:30:00Z" },
            ],
            recording_url: "recording_url",
            screenshot_urls: ["screenshot_urls"],
            failure_reason: "failure_reason",
            created_at: "2025-01-01T00:00:00Z",
            modified_at: "2025-01-01T00:05:00Z",
            queued_at: "2024-01-15T09:30:00Z",
            started_at: "2024-01-15T09:30:00Z",
            finished_at: "2024-01-15T09:30:00Z",
            app_url: "app_url",
            browser_session_id: "browser_session_id",
            max_screenshot_scrolls: 1,
            script_run: { ai_fallback_triggered: true },
            errors: [{ key: "value" }],
            run_with: "run_with",
            ai_fallback: true,
            run_request: {
                workflow_id: "wpid_123",
                parameters: { key: "value" },
                title: "title",
                proxy_location: "RESIDENTIAL",
                webhook_url: "webhook_url",
                totp_url: "totp_url",
                totp_identifier: "totp_identifier",
                browser_session_id: "browser_session_id",
                max_screenshot_scrolls: 1,
                extra_http_headers: { key: "value" },
                browser_address: "browser_address",
                ai_fallback: true,
                run_with: "run_with",
            },
        };
        server
            .mockEndpoint()
            .post("/v1/run/tasks/login")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.login({
            credential_type: "skyvern",
        });
        expect(response).toEqual({
            run_id: "tsk_123",
            status: "created",
            output: {
                key: "value",
            },
            downloaded_files: [
                {
                    url: "url",
                    checksum: "checksum",
                    filename: "filename",
                    modified_at: "2024-01-15T09:30:00Z",
                },
            ],
            recording_url: "recording_url",
            screenshot_urls: ["screenshot_urls"],
            failure_reason: "failure_reason",
            created_at: "2025-01-01T00:00:00Z",
            modified_at: "2025-01-01T00:05:00Z",
            queued_at: "2024-01-15T09:30:00Z",
            started_at: "2024-01-15T09:30:00Z",
            finished_at: "2024-01-15T09:30:00Z",
            app_url: "app_url",
            browser_session_id: "browser_session_id",
            max_screenshot_scrolls: 1,
            script_run: {
                ai_fallback_triggered: true,
            },
            errors: [
                {
                    key: "value",
                },
            ],
            run_with: "run_with",
            ai_fallback: true,
            run_request: {
                workflow_id: "wpid_123",
                parameters: {
                    key: "value",
                },
                title: "title",
                proxy_location: "RESIDENTIAL",
                webhook_url: "webhook_url",
                totp_url: "totp_url",
                totp_identifier: "totp_identifier",
                browser_session_id: "browser_session_id",
                max_screenshot_scrolls: 1,
                extra_http_headers: {
                    key: "value",
                },
                browser_address: "browser_address",
                ai_fallback: true,
                run_with: "run_with",
            },
        });
    });

    test("login (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { credential_type: "skyvern" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/run/tasks/login")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.login({
                credential_type: "skyvern",
            });
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("get_scripts (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                script_revision_id: "script_revision_id",
                script_id: "script_id",
                organization_id: "organization_id",
                run_id: "run_id",
                version: 1,
                created_at: "2024-01-15T09:30:00Z",
                modified_at: "2024-01-15T09:30:00Z",
                deleted_at: "2024-01-15T09:30:00Z",
            },
        ];
        server.mockEndpoint().get("/v1/scripts").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getScripts({
            page: 1,
            page_size: 10,
        });
        expect(response).toEqual([
            {
                script_revision_id: "script_revision_id",
                script_id: "script_id",
                organization_id: "organization_id",
                run_id: "run_id",
                version: 1,
                created_at: "2024-01-15T09:30:00Z",
                modified_at: "2024-01-15T09:30:00Z",
                deleted_at: "2024-01-15T09:30:00Z",
            },
        ]);
    });

    test("get_scripts (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/v1/scripts").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.getScripts();
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("create_script (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            script_id: "s_abc123",
            version: 1,
            run_id: "run_id",
            file_count: 1,
            file_tree: {
                key: {
                    type: "type",
                    size: 1,
                    mime_type: "mime_type",
                    content_hash: "content_hash",
                    created_at: "2024-01-15T09:30:00Z",
                    children: {},
                },
            },
            created_at: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .post("/v1/scripts")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.createScript();
        expect(response).toEqual({
            script_id: "s_abc123",
            version: 1,
            run_id: "run_id",
            file_count: 1,
            file_tree: {
                key: {
                    type: "type",
                    size: 1,
                    mime_type: "mime_type",
                    content_hash: "content_hash",
                    created_at: "2024-01-15T09:30:00Z",
                    children: {},
                },
            },
            created_at: "2024-01-15T09:30:00Z",
        });
    });

    test("create_script (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/scripts")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.createScript();
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("get_script (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            script_revision_id: "script_revision_id",
            script_id: "script_id",
            organization_id: "organization_id",
            run_id: "run_id",
            version: 1,
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
            deleted_at: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .get("/v1/scripts/s_abc123")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getScript("s_abc123");
        expect(response).toEqual({
            script_revision_id: "script_revision_id",
            script_id: "script_id",
            organization_id: "organization_id",
            run_id: "run_id",
            version: 1,
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
            deleted_at: "2024-01-15T09:30:00Z",
        });
    });

    test("get_script (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/scripts/script_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getScript("script_id");
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("deploy_script (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { files: [{ path: "src/main.py", content: "content" }] };
        const rawResponseBody = {
            script_id: "s_abc123",
            version: 1,
            run_id: "run_id",
            file_count: 1,
            file_tree: {
                key: {
                    type: "type",
                    size: 1,
                    mime_type: "mime_type",
                    content_hash: "content_hash",
                    created_at: "2024-01-15T09:30:00Z",
                    children: {},
                },
            },
            created_at: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .post("/v1/scripts/s_abc123/deploy")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.deployScript("s_abc123", {
            files: [
                {
                    path: "src/main.py",
                    content: "content",
                },
            ],
        });
        expect(response).toEqual({
            script_id: "s_abc123",
            version: 1,
            run_id: "run_id",
            file_count: 1,
            file_tree: {
                key: {
                    type: "type",
                    size: 1,
                    mime_type: "mime_type",
                    content_hash: "content_hash",
                    created_at: "2024-01-15T09:30:00Z",
                    children: {},
                },
            },
            created_at: "2024-01-15T09:30:00Z",
        });
    });

    test("deploy_script (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            files: [
                { path: "path", content: "content" },
                { path: "path", content: "content" },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/scripts/script_id/deploy")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.deployScript("script_id", {
                files: [
                    {
                        path: "path",
                        content: "content",
                    },
                    {
                        path: "path",
                        content: "content",
                    },
                ],
            });
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });
});
