# This file was auto-generated by Fern from our API Definition.

import asyncio
import time
import typing
from ..core.client_wrapper import SyncClientWrapper
from ..types.task_status import TaskStatus
from ..types.order_by import OrderBy
from ..types.sort_direction import SortDirection
from ..core.request_options import RequestOptions
from ..types.task import Task
from ..core.pydantic_utilities import parse_obj_as
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.http_validation_error import HttpValidationError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from .types.task_request_navigation_payload import TaskRequestNavigationPayload
from ..types.proxy_location import ProxyLocation
from .types.task_request_extracted_information_schema import TaskRequestExtractedInformationSchema
from ..types.task_type import TaskType
from ..types.create_task_response import CreateTaskResponse
from ..core.serialization import convert_and_respect_annotation_metadata
from ..types.step import Step
from ..core.jsonable_encoder import jsonable_encoder
from ..types.task_response import TaskResponse
from ..types.entity_type import EntityType
from ..types.artifact import Artifact
from ..types.action import Action
from ..types.run_workflow_response import RunWorkflowResponse
from ..types.workflow_run_status import WorkflowRunStatus
from ..types.workflow_run import WorkflowRun
from ..types.workflow_run_timeline import WorkflowRunTimeline
from ..types.workflow_run_status_response import WorkflowRunResponse
from ..types.workflow import Workflow
from ..types.ai_suggestion_base import AiSuggestionBase
from ..types.task_generation import TaskGeneration
from ..types.get_organizations_response import GetOrganizationsResponse
from ..types.organization import Organization
from ..types.get_organization_api_keys_response import GetOrganizationApiKeysResponse
from .. import core
from ..types.browser_session_response import BrowserSessionResponse
import datetime as dt
from ..types.totp_code import TotpCode
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AgentClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_tasks(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        task_status: typing.Optional[typing.Union[TaskStatus, typing.Sequence[TaskStatus]]] = None,
        workflow_run_id: typing.Optional[str] = None,
        only_standalone_tasks: typing.Optional[bool] = None,
        application: typing.Optional[str] = None,
        sort: typing.Optional[OrderBy] = None,
        order: typing.Optional[SortDirection] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Task]:
        """
        Get all tasks.
        :param page: Starting page, defaults to 1
        :param page_size: Page size, defaults to 10
        :param task_status: Task status filter
        :param workflow_run_id: Workflow run id filter
        :param only_standalone_tasks: Only standalone tasks, tasks which are part of a workflow run will be filtered out
        :param order: Direction to sort by, ascending or descending
        :param sort: Column to sort by, created_at or modified_at
        :return: List of tasks with pagination without steps populated. Steps can be populated by calling the
            get_agent_task endpoint.

        Parameters
        ----------
        page : typing.Optional[int]

        page_size : typing.Optional[int]

        task_status : typing.Optional[typing.Union[TaskStatus, typing.Sequence[TaskStatus]]]

        workflow_run_id : typing.Optional[str]

        only_standalone_tasks : typing.Optional[bool]

        application : typing.Optional[str]

        sort : typing.Optional[OrderBy]

        order : typing.Optional[SortDirection]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Task]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_tasks()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/tasks",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
                "task_status": task_status,
                "workflow_run_id": workflow_run_id,
                "only_standalone_tasks": only_standalone_tasks,
                "application": application,
                "sort": sort,
                "order": order,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Task],
                    parse_obj_as(
                        type_=typing.List[Task],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_task(
        self,
        *,
        url: str,
        api_key: typing.Optional[str] = None,
        max_steps_override: typing.Optional[int] = None,
        authorization: typing.Optional[str] = None,
        title: typing.Optional[str] = OMIT,
        webhook_callback_url: typing.Optional[str] = OMIT,
        totp_verification_url: typing.Optional[str] = OMIT,
        totp_identifier: typing.Optional[str] = OMIT,
        navigation_goal: typing.Optional[str] = OMIT,
        data_extraction_goal: typing.Optional[str] = OMIT,
        navigation_payload: typing.Optional[TaskRequestNavigationPayload] = OMIT,
        error_code_mapping: typing.Optional[typing.Dict[str, typing.Optional[str]]] = OMIT,
        proxy_location: typing.Optional[ProxyLocation] = OMIT,
        extracted_information_schema: typing.Optional[TaskRequestExtractedInformationSchema] = OMIT,
        complete_criterion: typing.Optional[str] = OMIT,
        terminate_criterion: typing.Optional[str] = OMIT,
        task_type: typing.Optional[TaskType] = OMIT,
        application: typing.Optional[str] = OMIT,
        browser_session_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateTaskResponse:
        """
        Parameters
        ----------
        url : str
            Starting URL for the task.

        api_key : typing.Optional[str]

        max_steps_override : typing.Optional[int]

        authorization : typing.Optional[str]

        title : typing.Optional[str]
            The title of the task.

        webhook_callback_url : typing.Optional[str]
            The URL to call when the task is completed.

        totp_verification_url : typing.Optional[str]

        totp_identifier : typing.Optional[str]

        navigation_goal : typing.Optional[str]
            The user's goal for the task.

        data_extraction_goal : typing.Optional[str]
            The user's goal for data extraction.

        navigation_payload : typing.Optional[TaskRequestNavigationPayload]
            The user's details needed to achieve the task.

        error_code_mapping : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            The mapping of error codes and their descriptions.

        proxy_location : typing.Optional[ProxyLocation]
            The location of the proxy to use for the task.

        extracted_information_schema : typing.Optional[TaskRequestExtractedInformationSchema]
            The requested schema of the extracted information.

        complete_criterion : typing.Optional[str]
            Criterion to complete

        terminate_criterion : typing.Optional[str]
            Criterion to terminate

        task_type : typing.Optional[TaskType]
            The type of the task

        application : typing.Optional[str]
            The application for which the task is running

        browser_session_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateTaskResponse
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.create_task(
            url="https://www.geico.com",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/tasks",
            method="POST",
            json={
                "title": title,
                "url": url,
                "webhook_callback_url": webhook_callback_url,
                "totp_verification_url": totp_verification_url,
                "totp_identifier": totp_identifier,
                "navigation_goal": navigation_goal,
                "data_extraction_goal": data_extraction_goal,
                "navigation_payload": convert_and_respect_annotation_metadata(
                    object_=navigation_payload, annotation=TaskRequestNavigationPayload, direction="write"
                ),
                "error_code_mapping": error_code_mapping,
                "proxy_location": proxy_location,
                "extracted_information_schema": convert_and_respect_annotation_metadata(
                    object_=extracted_information_schema,
                    annotation=TaskRequestExtractedInformationSchema,
                    direction="write",
                ),
                "complete_criterion": complete_criterion,
                "terminate_criterion": terminate_criterion,
                "task_type": task_type,
                "application": application,
                "browser_session_id": browser_session_id,
            },
            headers={
                "content-type": "application/json",
                "x-api-key": str(api_key) if api_key is not None else None,
                "x-max-steps-override": str(max_steps_override) if max_steps_override is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CreateTaskResponse,
                    parse_obj_as(
                        type_=CreateTaskResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def run_task(
        self,
        *,
        url: str,
        api_key: typing.Optional[str] = None,
        max_steps_override: typing.Optional[int] = None,
        authorization: typing.Optional[str] = None,
        title: typing.Optional[str] = OMIT,
        webhook_callback_url: typing.Optional[str] = OMIT,
        totp_verification_url: typing.Optional[str] = OMIT,
        totp_identifier: typing.Optional[str] = OMIT,
        navigation_goal: typing.Optional[str] = OMIT,
        data_extraction_goal: typing.Optional[str] = OMIT,
        navigation_payload: typing.Optional[TaskRequestNavigationPayload] = OMIT,
        error_code_mapping: typing.Optional[typing.Dict[str, typing.Optional[str]]] = OMIT,
        proxy_location: typing.Optional[ProxyLocation] = OMIT,
        extracted_information_schema: typing.Optional[TaskRequestExtractedInformationSchema] = OMIT,
        complete_criterion: typing.Optional[str] = OMIT,
        terminate_criterion: typing.Optional[str] = OMIT,
        task_type: typing.Optional[TaskType] = OMIT,
        application: typing.Optional[str] = OMIT,
        browser_session_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
        timeout_seconds: int = 600,
    ) -> TaskResponse:
        created_task = self.create_task(
            url=url,
            api_key=api_key,
            max_steps_override=max_steps_override,
            authorization=authorization,
            title=title,
            webhook_callback_url=webhook_callback_url,
            totp_verification_url=totp_verification_url,
            totp_identifier=totp_identifier,
            navigation_goal=navigation_goal,
            data_extraction_goal=data_extraction_goal,
            navigation_payload=navigation_payload,
            error_code_mapping=error_code_mapping,
            proxy_location=proxy_location,
            extracted_information_schema=extracted_information_schema,
            complete_criterion=complete_criterion,
            terminate_criterion=terminate_criterion,
            task_type=task_type,
            application=application,
            browser_session_id=browser_session_id,
            request_options=request_options,
        )

        start_time = time.time()
        while True:
            if time.time() - start_time > timeout_seconds:
                raise TimeoutError(f"Task timed out after {timeout_seconds} seconds")

            task = self.get_task(
                created_task.task_id, api_key=api_key, authorization=authorization, request_options=request_options
            )
            if task.status in ["timed_out", "failed", "terminated", "completed", "canceled"]:
                return task
            time.sleep(1)

    def get_task_steps(
        self,
        task_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Step]:
        """
        Get all steps for a task.
        :param task_id:
        :return: List of steps for a task with pagination.

        Parameters
        ----------
        task_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Step]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_task_steps(
            task_id="task_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/tasks/{jsonable_encoder(task_id)}/steps",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Step],
                    parse_obj_as(
                        type_=typing.List[Step],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def execute_task_steps(
        self,
        task_id: str,
        *,
        step_id: typing.Optional[str] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Step:
        """
        Parameters
        ----------
        task_id : str

        step_id : typing.Optional[str]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Step
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.execute_task_steps(
            task_id="task_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/tasks/{jsonable_encoder(task_id)}/steps",
            method="POST",
            params={
                "step_id": step_id,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Step,
                    parse_obj_as(
                        type_=Step,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def execute_task_step(
        self,
        task_id: str,
        step_id: typing.Optional[str],
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Step:
        """
        Parameters
        ----------
        task_id : str

        step_id : typing.Optional[str]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Step
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.execute_task_step(
            task_id="task_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/tasks/{jsonable_encoder(task_id)}/steps/{jsonable_encoder(step_id)}",
            method="POST",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Step,
                    parse_obj_as(
                        type_=Step,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_task(
        self,
        task_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskResponse:
        """
        Parameters
        ----------
        task_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskResponse
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_task(
            task_id="task_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/tasks/{jsonable_encoder(task_id)}",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TaskResponse,
                    parse_obj_as(
                        type_=TaskResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def cancel_task(
        self,
        task_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Parameters
        ----------
        task_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.cancel_task(
            task_id="task_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/tasks/{jsonable_encoder(task_id)}/cancel",
            method="POST",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def cancel_workflow_run(
        self,
        workflow_run_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Parameters
        ----------
        workflow_run_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.cancel_workflow_run(
            workflow_run_id="workflow_run_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/workflows/runs/{jsonable_encoder(workflow_run_id)}/cancel",
            method="POST",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def retry_webhook(
        self,
        task_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskResponse:
        """
        Parameters
        ----------
        task_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskResponse
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.retry_webhook(
            task_id="task_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/tasks/{jsonable_encoder(task_id)}/retry_webhook",
            method="POST",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TaskResponse,
                    parse_obj_as(
                        type_=TaskResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_task_internal(
        self,
        task_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Task]:
        """
        Get all tasks.
        :param page: Starting page, defaults to 1
        :param page_size:
        :return: List of tasks with pagination without steps populated. Steps can be populated by calling the
            get_agent_task endpoint.

        Parameters
        ----------
        task_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Task]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_task_internal(
            task_id="task_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/internal/tasks/{jsonable_encoder(task_id)}",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Task],
                    parse_obj_as(
                        type_=typing.List[Task],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_tasks_internal(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Task]:
        """
        Get all tasks.
        :param page: Starting page, defaults to 1
        :param page_size: Page size, defaults to 10
        :return: List of tasks with pagination without steps populated. Steps can be populated by calling the
            get_agent_task endpoint.

        Parameters
        ----------
        page : typing.Optional[int]

        page_size : typing.Optional[int]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Task]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_tasks_internal()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/internal/tasks",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Task],
                    parse_obj_as(
                        type_=typing.List[Task],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_entity_artifacts(
        self,
        entity_type: EntityType,
        entity_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Artifact]:
        """
        Get all artifacts for an entity (step, task, workflow_run).

        Args:
            entity_type: Type of entity to fetch artifacts for
            entity_id: ID of the entity
            current_org: Current organization from auth

        Returns:
            List of artifacts for the entity

        Raises:
            HTTPException: If entity is not supported

        Parameters
        ----------
        entity_type : EntityType

        entity_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Artifact]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_entity_artifacts(
            entity_type="step",
            entity_id="entity_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/{jsonable_encoder(entity_type)}/{jsonable_encoder(entity_id)}/artifacts",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Artifact],
                    parse_obj_as(
                        type_=typing.List[Artifact],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_task_step_artifacts(
        self,
        task_id: str,
        step_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Artifact]:
        """
        Get all artifacts for a list of steps.
        :param task_id:
        :param step_id:
        :return: List of artifacts for a list of steps.

        Parameters
        ----------
        task_id : str

        step_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Artifact]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_task_step_artifacts(
            task_id="task_id",
            step_id="step_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/tasks/{jsonable_encoder(task_id)}/steps/{jsonable_encoder(step_id)}/artifacts",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Artifact],
                    parse_obj_as(
                        type_=typing.List[Artifact],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_task_actions(
        self,
        task_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Action]:
        """
        Parameters
        ----------
        task_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Action]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_task_actions(
            task_id="task_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/tasks/{jsonable_encoder(task_id)}/actions",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Action],
                    parse_obj_as(
                        type_=typing.List[Action],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def execute_workflow(
        self,
        workflow_id: str,
        *,
        version: typing.Optional[int] = None,
        template: typing.Optional[bool] = None,
        api_key: typing.Optional[str] = None,
        max_steps_override: typing.Optional[int] = None,
        authorization: typing.Optional[str] = None,
        data: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        proxy_location: typing.Optional[ProxyLocation] = OMIT,
        webhook_callback_url: typing.Optional[str] = OMIT,
        totp_verification_url: typing.Optional[str] = OMIT,
        totp_identifier: typing.Optional[str] = OMIT,
        browser_session_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> RunWorkflowResponse:
        """
        Parameters
        ----------
        workflow_id : str

        version : typing.Optional[int]

        template : typing.Optional[bool]

        api_key : typing.Optional[str]

        max_steps_override : typing.Optional[int]

        authorization : typing.Optional[str]

        data : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        proxy_location : typing.Optional[ProxyLocation]

        webhook_callback_url : typing.Optional[str]

        totp_verification_url : typing.Optional[str]

        totp_identifier : typing.Optional[str]

        browser_session_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        RunWorkflowResponse
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.execute_workflow(
            workflow_id="workflow_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/workflows/{jsonable_encoder(workflow_id)}/run",
            method="POST",
            params={
                "version": version,
                "template": template,
            },
            json={
                "data": data,
                "proxy_location": proxy_location,
                "webhook_callback_url": webhook_callback_url,
                "totp_verification_url": totp_verification_url,
                "totp_identifier": totp_identifier,
                "browser_session_id": browser_session_id,
            },
            headers={
                "content-type": "application/json",
                "x-api-key": str(api_key) if api_key is not None else None,
                "x-max-steps-override": str(max_steps_override) if max_steps_override is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    RunWorkflowResponse,
                    parse_obj_as(
                        type_=RunWorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_workflow_runs(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        status: typing.Optional[typing.Union[WorkflowRunStatus, typing.Sequence[WorkflowRunStatus]]] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[WorkflowRun]:
        """
        Parameters
        ----------
        page : typing.Optional[int]

        page_size : typing.Optional[int]

        status : typing.Optional[typing.Union[WorkflowRunStatus, typing.Sequence[WorkflowRunStatus]]]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WorkflowRun]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_workflow_runs()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/workflows/runs",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
                "status": status,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WorkflowRun],
                    parse_obj_as(
                        type_=typing.List[WorkflowRun],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_workflow_runs_for_workflow_permanent_id(
        self,
        workflow_permanent_id: str,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        status: typing.Optional[typing.Union[WorkflowRunStatus, typing.Sequence[WorkflowRunStatus]]] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[WorkflowRun]:
        """
        Parameters
        ----------
        workflow_permanent_id : str

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        status : typing.Optional[typing.Union[WorkflowRunStatus, typing.Sequence[WorkflowRunStatus]]]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WorkflowRun]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_workflow_runs_for_workflow_permanent_id(
            workflow_permanent_id="workflow_permanent_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/workflows/{jsonable_encoder(workflow_permanent_id)}/runs",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
                "status": status,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WorkflowRun],
                    parse_obj_as(
                        type_=typing.List[WorkflowRun],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_workflow_run(
        self,
        workflow_id: str,
        workflow_run_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        workflow_id : str

        workflow_run_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_workflow_run(
            workflow_id="workflow_id",
            workflow_run_id="workflow_run_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/workflows/{jsonable_encoder(workflow_id)}/runs/{jsonable_encoder(workflow_run_id)}",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_workflow_run_timeline(
        self,
        workflow_run_id: str,
        workflow_id: str,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[WorkflowRunTimeline]:
        """
        Parameters
        ----------
        workflow_run_id : str

        workflow_id : str

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WorkflowRunTimeline]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_workflow_run_timeline(
            workflow_run_id="workflow_run_id",
            workflow_id="workflow_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/workflows/{jsonable_encoder(workflow_id)}/runs/{jsonable_encoder(workflow_run_id)}/timeline",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WorkflowRunTimeline],
                    parse_obj_as(
                        type_=typing.List[WorkflowRunTimeline],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_workflow_run_by_run_id(
        self,
        workflow_run_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowRunResponse:
        """
        Parameters
        ----------
        workflow_run_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowRunResponse
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_workflow_run_by_run_id(
            workflow_run_id="workflow_run_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/workflows/runs/{jsonable_encoder(workflow_run_id)}",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WorkflowRunResponse,
                    parse_obj_as(
                        type_=WorkflowRunResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_workflows(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        only_saved_tasks: typing.Optional[bool] = None,
        only_workflows: typing.Optional[bool] = None,
        title: typing.Optional[str] = None,
        template: typing.Optional[bool] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Workflow]:
        """
        Get all workflows with the latest version for the organization.

        Parameters
        ----------
        page : typing.Optional[int]

        page_size : typing.Optional[int]

        only_saved_tasks : typing.Optional[bool]

        only_workflows : typing.Optional[bool]

        title : typing.Optional[str]

        template : typing.Optional[bool]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Workflow]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_workflows()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/workflows",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
                "only_saved_tasks": only_saved_tasks,
                "only_workflows": only_workflows,
                "title": title,
                "template": template,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Workflow],
                    parse_obj_as(
                        type_=typing.List[Workflow],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_workflow(
        self,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Workflow:
        """
        Parameters
        ----------
        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Workflow
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.create_workflow()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/workflows",
            method="POST",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Workflow,
                    parse_obj_as(
                        type_=Workflow,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_workflow(
        self,
        workflow_permanent_id: str,
        *,
        version: typing.Optional[int] = None,
        template: typing.Optional[bool] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Workflow:
        """
        Parameters
        ----------
        workflow_permanent_id : str

        version : typing.Optional[int]

        template : typing.Optional[bool]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Workflow
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_workflow(
            workflow_permanent_id="workflow_permanent_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/workflows/{jsonable_encoder(workflow_permanent_id)}",
            method="GET",
            params={
                "version": version,
                "template": template,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Workflow,
                    parse_obj_as(
                        type_=Workflow,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_workflow(
        self,
        workflow_permanent_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Workflow:
        """
        Parameters
        ----------
        workflow_permanent_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Workflow
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.update_workflow(
            workflow_permanent_id="workflow_permanent_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/workflows/{jsonable_encoder(workflow_permanent_id)}",
            method="PUT",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Workflow,
                    parse_obj_as(
                        type_=Workflow,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_workflow(
        self,
        workflow_permanent_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Parameters
        ----------
        workflow_permanent_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.delete_workflow(
            workflow_permanent_id="workflow_permanent_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/workflows/{jsonable_encoder(workflow_permanent_id)}",
            method="DELETE",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_workflows(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        only_saved_tasks: typing.Optional[bool] = None,
        only_workflows: typing.Optional[bool] = None,
        title: typing.Optional[str] = None,
        template: typing.Optional[bool] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Workflow]:
        """
        Get all workflows with the latest version for the organization.

        Parameters
        ----------
        page : typing.Optional[int]

        page_size : typing.Optional[int]

        only_saved_tasks : typing.Optional[bool]

        only_workflows : typing.Optional[bool]

        title : typing.Optional[str]

        template : typing.Optional[bool]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Workflow]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.list_workflows()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/workflows/",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
                "only_saved_tasks": only_saved_tasks,
                "only_workflows": only_workflows,
                "title": title,
                "template": template,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Workflow],
                    parse_obj_as(
                        type_=typing.List[Workflow],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def make_ai_suggestion(
        self,
        *,
        input: str,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        context: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AiSuggestionBase:
        """
        Parameters
        ----------
        input : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        context : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AiSuggestionBase
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.make_ai_suggestion(
            input="input",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/suggest/data_schema/",
            method="POST",
            json={
                "input": input,
                "context": context,
            },
            headers={
                "content-type": "application/json",
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AiSuggestionBase,
                    parse_obj_as(
                        type_=AiSuggestionBase,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def generate_task(
        self,
        *,
        prompt: str,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskGeneration:
        """
        Parameters
        ----------
        prompt : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskGeneration
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.generate_task(
            prompt="prompt",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/generate/task/",
            method="POST",
            json={
                "prompt": prompt,
            },
            headers={
                "content-type": "application/json",
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TaskGeneration,
                    parse_obj_as(
                        type_=TaskGeneration,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_organizations(
        self,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetOrganizationsResponse:
        """
        Parameters
        ----------
        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetOrganizationsResponse
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_organizations()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/organizations",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetOrganizationsResponse,
                    parse_obj_as(
                        type_=GetOrganizationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_organization(
        self,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        max_steps_per_run: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Organization:
        """
        Parameters
        ----------
        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        max_steps_per_run : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Organization
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.update_organization()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/organizations",
            method="PUT",
            json={
                "max_steps_per_run": max_steps_per_run,
            },
            headers={
                "content-type": "application/json",
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Organization,
                    parse_obj_as(
                        type_=Organization,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_org_api_keys(
        self,
        organization_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetOrganizationApiKeysResponse:
        """
        Parameters
        ----------
        organization_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetOrganizationApiKeysResponse
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_org_api_keys(
            organization_id="organization_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/organizations/{jsonable_encoder(organization_id)}/apikeys",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetOrganizationApiKeysResponse,
                    parse_obj_as(
                        type_=GetOrganizationApiKeysResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def upload_file(
        self,
        *,
        file: core.File,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.upload_file()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/upload_file",
            method="POST",
            data={},
            files={
                "file": file,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_browser_session_by_id(
        self,
        browser_session_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BrowserSessionResponse:
        """
        Parameters
        ----------
        browser_session_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BrowserSessionResponse
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_browser_session_by_id(
            browser_session_id="browser_session_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/browser_sessions/{jsonable_encoder(browser_session_id)}",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BrowserSessionResponse,
                    parse_obj_as(
                        type_=BrowserSessionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_browser_sessions(
        self,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[BrowserSessionResponse]:
        """
        Get all active browser sessions for the organization

        Parameters
        ----------
        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[BrowserSessionResponse]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_browser_sessions()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/browser_sessions",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[BrowserSessionResponse],
                    parse_obj_as(
                        type_=typing.List[BrowserSessionResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_browser_session(
        self,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BrowserSessionResponse:
        """
        Parameters
        ----------
        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BrowserSessionResponse
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.create_browser_session()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/browser_sessions",
            method="POST",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BrowserSessionResponse,
                    parse_obj_as(
                        type_=BrowserSessionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def close_browser_sessions(
        self,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Parameters
        ----------
        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.close_browser_sessions()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/browser_sessions/close",
            method="POST",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def close_browser_session(
        self,
        session_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Parameters
        ----------
        session_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.close_browser_session(
            session_id="session_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/browser_sessions/{jsonable_encoder(session_id)}/close",
            method="POST",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def observer_task_v_2(
        self,
        *,
        user_prompt: str,
        max_iterations_override: typing.Optional[int] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        url: typing.Optional[str] = OMIT,
        browser_session_id: typing.Optional[str] = OMIT,
        webhook_callback_url: typing.Optional[str] = OMIT,
        totp_verification_url: typing.Optional[str] = OMIT,
        totp_identifier: typing.Optional[str] = OMIT,
        proxy_location: typing.Optional[ProxyLocation] = OMIT,
        publish_workflow: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        user_prompt : str

        max_iterations_override : typing.Optional[int]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        url : typing.Optional[str]

        browser_session_id : typing.Optional[str]

        webhook_callback_url : typing.Optional[str]

        totp_verification_url : typing.Optional[str]

        totp_identifier : typing.Optional[str]

        proxy_location : typing.Optional[ProxyLocation]

        publish_workflow : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.observer_task_v_2(
            user_prompt="user_prompt",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v2/tasks",
            method="POST",
            json={
                "user_prompt": user_prompt,
                "url": url,
                "browser_session_id": browser_session_id,
                "webhook_callback_url": webhook_callback_url,
                "totp_verification_url": totp_verification_url,
                "totp_identifier": totp_identifier,
                "proxy_location": proxy_location,
                "publish_workflow": publish_workflow,
            },
            headers={
                "content-type": "application/json",
                "x-max-iterations-override": str(max_iterations_override)
                if max_iterations_override is not None
                else None,
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_observer_task_v_2(
        self,
        task_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        task_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_observer_task_v_2(
            task_id="task_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v2/tasks/{jsonable_encoder(task_id)}",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def run_observer_task_v_2(
        self,
        *,
        user_prompt: str,
        max_iterations_override: typing.Optional[int] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        url: typing.Optional[str] = OMIT,
        browser_session_id: typing.Optional[str] = OMIT,
        webhook_callback_url: typing.Optional[str] = OMIT,
        totp_verification_url: typing.Optional[str] = OMIT,
        totp_identifier: typing.Optional[str] = OMIT,
        proxy_location: typing.Optional[ProxyLocation] = OMIT,
        publish_workflow: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
        timeout_seconds: int = 600,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        observer_task = self.observer_task_v_2(
            user_prompt=user_prompt,
            max_iterations_override=max_iterations_override,
            api_key=api_key,
            authorization=authorization,
            url=url,
            browser_session_id=browser_session_id,
            webhook_callback_url=webhook_callback_url,
            totp_verification_url=totp_verification_url,
            totp_identifier=totp_identifier,
            proxy_location=proxy_location,
            publish_workflow=publish_workflow,
            request_options=request_options,
        )
        task_id = observer_task.get("task_id")

        start_time = time.time()
        while True:
            if time.time() - start_time > timeout_seconds:
                raise TimeoutError(f"Task timed out after {timeout_seconds} seconds")

            task = self.get_observer_task_v_2(
                str(task_id), api_key=api_key, authorization=authorization, request_options=request_options
            )
            if str(task.get("status")) in ["timed_out", "failed", "terminated", "completed", "canceled"]:
                return task
            time.sleep(1)

    def save_totp_code(
        self,
        *,
        totp_identifier: str,
        content: str,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        task_id: typing.Optional[str] = OMIT,
        workflow_id: typing.Optional[str] = OMIT,
        source: typing.Optional[str] = OMIT,
        expired_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TotpCode:
        """
        Parameters
        ----------
        totp_identifier : str

        content : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        task_id : typing.Optional[str]

        workflow_id : typing.Optional[str]

        source : typing.Optional[str]

        expired_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TotpCode
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.save_totp_code(
            totp_identifier="totp_identifier",
            content="content",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/totp",
            method="POST",
            json={
                "totp_identifier": totp_identifier,
                "task_id": task_id,
                "workflow_id": workflow_id,
                "source": source,
                "content": content,
                "expired_at": expired_at,
            },
            headers={
                "content-type": "application/json",
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TotpCode,
                    parse_obj_as(
                        type_=TotpCode,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_eval_workflow_runs(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[WorkflowRun]:
        """
        Parameters
        ----------
        page : typing.Optional[int]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WorkflowRun]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_eval_workflow_runs()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/eval/workflows/runs",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WorkflowRun],
                    parse_obj_as(
                        type_=typing.List[WorkflowRun],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_eval_workflow_run(
        self, workflow_id: str, workflow_run_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        workflow_id : str

        workflow_run_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_eval_workflow_run(
            workflow_id="workflow_id",
            workflow_run_id="workflow_run_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/eval/workflows/{jsonable_encoder(workflow_id)}/runs/{jsonable_encoder(workflow_run_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_eval_workflow_run_timeline(
        self, workflow_run_id: str, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[WorkflowRunTimeline]:
        """
        Parameters
        ----------
        workflow_run_id : str

        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WorkflowRunTimeline]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_eval_workflow_run_timeline(
            workflow_run_id="workflow_run_id",
            workflow_id="workflow_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/eval/workflows/{jsonable_encoder(workflow_id)}/runs/{jsonable_encoder(workflow_run_id)}/timeline/",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WorkflowRunTimeline],
                    parse_obj_as(
                        type_=typing.List[WorkflowRunTimeline],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_workflow_run_timeline(
        self, workflow_run_id: str, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[WorkflowRunTimeline]:
        """
        Parameters
        ----------
        workflow_run_id : str

        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WorkflowRunTimeline]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.list_workflow_run_timeline(
            workflow_run_id="workflow_run_id",
            workflow_id="workflow_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/eval/workflows/{jsonable_encoder(workflow_id)}/runs/{jsonable_encoder(workflow_run_id)}/timeline",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WorkflowRunTimeline],
                    parse_obj_as(
                        type_=typing.List[WorkflowRunTimeline],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_eval_workflow_run_by_run_id(
        self, workflow_run_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> WorkflowRunResponse:
        """
        Parameters
        ----------
        workflow_run_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowRunResponse
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_eval_workflow_run_by_run_id(
            workflow_run_id="workflow_run_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/eval/workflows/runs/{jsonable_encoder(workflow_run_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WorkflowRunResponse,
                    parse_obj_as(
                        type_=WorkflowRunResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_eval_workflow(
        self,
        workflow_permanent_id: str,
        *,
        version: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Workflow:
        """
        Parameters
        ----------
        workflow_permanent_id : str

        version : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Workflow
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_eval_workflow(
            workflow_permanent_id="workflow_permanent_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/eval/workflows/{jsonable_encoder(workflow_permanent_id)}/",
            method="GET",
            params={
                "version": version,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Workflow,
                    parse_obj_as(
                        type_=Workflow,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_eval_workflow_runs_for_workflow_permanent_id(
        self,
        workflow_permanent_id: str,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[WorkflowRun]:
        """
        Parameters
        ----------
        workflow_permanent_id : str

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WorkflowRun]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_eval_workflow_runs_for_workflow_permanent_id(
            workflow_permanent_id="workflow_permanent_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/eval/workflows/{jsonable_encoder(workflow_permanent_id)}/runs",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WorkflowRun],
                    parse_obj_as(
                        type_=typing.List[WorkflowRun],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_eval_entity_artifacts(
        self, entity_type: EntityType, entity_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[Artifact]:
        """
        Get all artifacts for an entity (step, task, workflow_run).

        Args:
            entity_type: Type of entity to fetch artifacts for
            entity_id: ID of the entity
            current_org: Current organization from auth

        Returns:
            List of artifacts for the entity

        Raises:
            HTTPException: If entity is not supported

        Parameters
        ----------
        entity_type : EntityType

        entity_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Artifact]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_eval_entity_artifacts(
            entity_type="step",
            entity_id="entity_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/eval/{jsonable_encoder(entity_type)}/{jsonable_encoder(entity_id)}/artifacts",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Artifact],
                    parse_obj_as(
                        type_=typing.List[Artifact],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_eval_task_actions(
        self, task_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[Action]:
        """
        Parameters
        ----------
        task_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Action]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_eval_task_actions(
            task_id="task_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/eval/tasks/{jsonable_encoder(task_id)}/actions",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Action],
                    parse_obj_as(
                        type_=typing.List[Action],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_eval_task_step_artifacts(
        self, task_id: str, step_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[Artifact]:
        """
        Get all artifacts for a list of steps.
        :param task_id:
        :param step_id:
        :return: List of artifacts for a list of steps.

        Parameters
        ----------
        task_id : str

        step_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Artifact]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_eval_task_step_artifacts(
            task_id="task_id",
            step_id="step_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/eval/tasks/{jsonable_encoder(task_id)}/steps/{jsonable_encoder(step_id)}/artifacts",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Artifact],
                    parse_obj_as(
                        type_=typing.List[Artifact],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_eval_task_steps(
        self, task_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[Step]:
        """
        Get all steps for a task.
        :param task_id:
        :return: List of steps for a task with pagination.

        Parameters
        ----------
        task_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Step]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_eval_task_steps(
            task_id="task_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/eval/tasks/{jsonable_encoder(task_id)}/steps",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Step],
                    parse_obj_as(
                        type_=typing.List[Step],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_agent_tasks(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        task_status: typing.Optional[typing.Union[TaskStatus, typing.Sequence[TaskStatus]]] = None,
        workflow_run_id: typing.Optional[str] = None,
        only_standalone_tasks: typing.Optional[bool] = None,
        application: typing.Optional[str] = None,
        sort: typing.Optional[OrderBy] = None,
        order: typing.Optional[SortDirection] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Task]:
        """
        Get all tasks.
        :param page: Starting page, defaults to 1
        :param page_size: Page size, defaults to 10
        :param task_status: Task status filter
        :param workflow_run_id: Workflow run id filter
        :param only_standalone_tasks: Only standalone tasks, tasks which are part of a workflow run will be filtered out
        :param order: Direction to sort by, ascending or descending
        :param sort: Column to sort by, created_at or modified_at
        :return: List of tasks with pagination without steps populated. Steps can be populated by calling the
            get_agent_task endpoint.

        Parameters
        ----------
        page : typing.Optional[int]

        page_size : typing.Optional[int]

        task_status : typing.Optional[typing.Union[TaskStatus, typing.Sequence[TaskStatus]]]

        workflow_run_id : typing.Optional[str]

        only_standalone_tasks : typing.Optional[bool]

        application : typing.Optional[str]

        sort : typing.Optional[OrderBy]

        order : typing.Optional[SortDirection]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Task]
            Successful Response

        Examples
        --------
        from skyverndocs import Skyvern

        client = Skyvern()
        client.agent.get_agent_tasks()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/eval/tasks",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
                "task_status": task_status,
                "workflow_run_id": workflow_run_id,
                "only_standalone_tasks": only_standalone_tasks,
                "application": application,
                "sort": sort,
                "order": order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Task],
                    parse_obj_as(
                        type_=typing.List[Task],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAgentClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_tasks(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        task_status: typing.Optional[typing.Union[TaskStatus, typing.Sequence[TaskStatus]]] = None,
        workflow_run_id: typing.Optional[str] = None,
        only_standalone_tasks: typing.Optional[bool] = None,
        application: typing.Optional[str] = None,
        sort: typing.Optional[OrderBy] = None,
        order: typing.Optional[SortDirection] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Task]:
        """
        Get all tasks.
        :param page: Starting page, defaults to 1
        :param page_size: Page size, defaults to 10
        :param task_status: Task status filter
        :param workflow_run_id: Workflow run id filter
        :param only_standalone_tasks: Only standalone tasks, tasks which are part of a workflow run will be filtered out
        :param order: Direction to sort by, ascending or descending
        :param sort: Column to sort by, created_at or modified_at
        :return: List of tasks with pagination without steps populated. Steps can be populated by calling the
            get_agent_task endpoint.

        Parameters
        ----------
        page : typing.Optional[int]

        page_size : typing.Optional[int]

        task_status : typing.Optional[typing.Union[TaskStatus, typing.Sequence[TaskStatus]]]

        workflow_run_id : typing.Optional[str]

        only_standalone_tasks : typing.Optional[bool]

        application : typing.Optional[str]

        sort : typing.Optional[OrderBy]

        order : typing.Optional[SortDirection]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Task]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_tasks()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/tasks",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
                "task_status": task_status,
                "workflow_run_id": workflow_run_id,
                "only_standalone_tasks": only_standalone_tasks,
                "application": application,
                "sort": sort,
                "order": order,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Task],
                    parse_obj_as(
                        type_=typing.List[Task],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_task(
        self,
        *,
        url: str,
        api_key: typing.Optional[str] = None,
        max_steps_override: typing.Optional[int] = None,
        authorization: typing.Optional[str] = None,
        title: typing.Optional[str] = OMIT,
        webhook_callback_url: typing.Optional[str] = OMIT,
        totp_verification_url: typing.Optional[str] = OMIT,
        totp_identifier: typing.Optional[str] = OMIT,
        navigation_goal: typing.Optional[str] = OMIT,
        data_extraction_goal: typing.Optional[str] = OMIT,
        navigation_payload: typing.Optional[TaskRequestNavigationPayload] = OMIT,
        error_code_mapping: typing.Optional[typing.Dict[str, typing.Optional[str]]] = OMIT,
        proxy_location: typing.Optional[ProxyLocation] = OMIT,
        extracted_information_schema: typing.Optional[TaskRequestExtractedInformationSchema] = OMIT,
        complete_criterion: typing.Optional[str] = OMIT,
        terminate_criterion: typing.Optional[str] = OMIT,
        task_type: typing.Optional[TaskType] = OMIT,
        application: typing.Optional[str] = OMIT,
        browser_session_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateTaskResponse:
        """
        Parameters
        ----------
        url : str
            Starting URL for the task.

        api_key : typing.Optional[str]

        max_steps_override : typing.Optional[int]

        authorization : typing.Optional[str]

        title : typing.Optional[str]
            The title of the task.

        webhook_callback_url : typing.Optional[str]
            The URL to call when the task is completed.

        totp_verification_url : typing.Optional[str]

        totp_identifier : typing.Optional[str]

        navigation_goal : typing.Optional[str]
            The user's goal for the task.

        data_extraction_goal : typing.Optional[str]
            The user's goal for data extraction.

        navigation_payload : typing.Optional[TaskRequestNavigationPayload]
            The user's details needed to achieve the task.

        error_code_mapping : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            The mapping of error codes and their descriptions.

        proxy_location : typing.Optional[ProxyLocation]
            The location of the proxy to use for the task.

        extracted_information_schema : typing.Optional[TaskRequestExtractedInformationSchema]
            The requested schema of the extracted information.

        complete_criterion : typing.Optional[str]
            Criterion to complete

        terminate_criterion : typing.Optional[str]
            Criterion to terminate

        task_type : typing.Optional[TaskType]
            The type of the task

        application : typing.Optional[str]
            The application for which the task is running

        browser_session_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateTaskResponse
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.create_task(
                url="https://www.geico.com",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/tasks",
            method="POST",
            json={
                "title": title,
                "url": url,
                "webhook_callback_url": webhook_callback_url,
                "totp_verification_url": totp_verification_url,
                "totp_identifier": totp_identifier,
                "navigation_goal": navigation_goal,
                "data_extraction_goal": data_extraction_goal,
                "navigation_payload": convert_and_respect_annotation_metadata(
                    object_=navigation_payload, annotation=TaskRequestNavigationPayload, direction="write"
                ),
                "error_code_mapping": error_code_mapping,
                "proxy_location": proxy_location,
                "extracted_information_schema": convert_and_respect_annotation_metadata(
                    object_=extracted_information_schema,
                    annotation=TaskRequestExtractedInformationSchema,
                    direction="write",
                ),
                "complete_criterion": complete_criterion,
                "terminate_criterion": terminate_criterion,
                "task_type": task_type,
                "application": application,
                "browser_session_id": browser_session_id,
            },
            headers={
                "content-type": "application/json",
                "x-api-key": str(api_key) if api_key is not None else None,
                "x-max-steps-override": str(max_steps_override) if max_steps_override is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CreateTaskResponse,
                    parse_obj_as(
                        type_=CreateTaskResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def run_task(
        self,
        *,
        url: str,
        api_key: typing.Optional[str] = None,
        max_steps_override: typing.Optional[int] = None,
        authorization: typing.Optional[str] = None,
        title: typing.Optional[str] = OMIT,
        webhook_callback_url: typing.Optional[str] = OMIT,
        totp_verification_url: typing.Optional[str] = OMIT,
        totp_identifier: typing.Optional[str] = OMIT,
        navigation_goal: typing.Optional[str] = OMIT,
        data_extraction_goal: typing.Optional[str] = OMIT,
        navigation_payload: typing.Optional[TaskRequestNavigationPayload] = OMIT,
        error_code_mapping: typing.Optional[typing.Dict[str, typing.Optional[str]]] = OMIT,
        proxy_location: typing.Optional[ProxyLocation] = OMIT,
        extracted_information_schema: typing.Optional[TaskRequestExtractedInformationSchema] = OMIT,
        complete_criterion: typing.Optional[str] = OMIT,
        terminate_criterion: typing.Optional[str] = OMIT,
        task_type: typing.Optional[TaskType] = OMIT,
        application: typing.Optional[str] = OMIT,
        browser_session_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
        timeout_seconds: int = 600,
    ) -> TaskResponse:
        created_task = await self.create_task(
            url=url,
            api_key=api_key,
            max_steps_override=max_steps_override,
            authorization=authorization,
            title=title,
            webhook_callback_url=webhook_callback_url,
            totp_verification_url=totp_verification_url,
            totp_identifier=totp_identifier,
            navigation_goal=navigation_goal,
            data_extraction_goal=data_extraction_goal,
            navigation_payload=navigation_payload,
            error_code_mapping=error_code_mapping,
            proxy_location=proxy_location,
            extracted_information_schema=extracted_information_schema,
            complete_criterion=complete_criterion,
            terminate_criterion=terminate_criterion,
            task_type=task_type,
            application=application,
            browser_session_id=browser_session_id,
            request_options=request_options,
        )

        async with asyncio.timeout(timeout_seconds):
            while True:
                task = await self.get_task(
                    created_task.task_id, api_key=api_key, authorization=authorization, request_options=request_options
                )
                if task.status in ["timed_out", "failed", "terminated", "completed", "canceled"]:
                    return task
                await asyncio.sleep(1)

    async def get_task_steps(
        self,
        task_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Step]:
        """
        Get all steps for a task.
        :param task_id:
        :return: List of steps for a task with pagination.

        Parameters
        ----------
        task_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Step]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_task_steps(
                task_id="task_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/tasks/{jsonable_encoder(task_id)}/steps",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Step],
                    parse_obj_as(
                        type_=typing.List[Step],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def execute_task_steps(
        self,
        task_id: str,
        *,
        step_id: typing.Optional[str] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Step:
        """
        Parameters
        ----------
        task_id : str

        step_id : typing.Optional[str]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Step
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.execute_task_steps(
                task_id="task_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/tasks/{jsonable_encoder(task_id)}/steps",
            method="POST",
            params={
                "step_id": step_id,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Step,
                    parse_obj_as(
                        type_=Step,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def execute_task_step(
        self,
        task_id: str,
        step_id: typing.Optional[str],
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Step:
        """
        Parameters
        ----------
        task_id : str

        step_id : typing.Optional[str]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Step
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.execute_task_step(
                task_id="task_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/tasks/{jsonable_encoder(task_id)}/steps/{jsonable_encoder(step_id)}",
            method="POST",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Step,
                    parse_obj_as(
                        type_=Step,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_task(
        self,
        task_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskResponse:
        """
        Parameters
        ----------
        task_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskResponse
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_task(
                task_id="task_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/tasks/{jsonable_encoder(task_id)}",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TaskResponse,
                    parse_obj_as(
                        type_=TaskResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def cancel_task(
        self,
        task_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Parameters
        ----------
        task_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.cancel_task(
                task_id="task_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/tasks/{jsonable_encoder(task_id)}/cancel",
            method="POST",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def cancel_workflow_run(
        self,
        workflow_run_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Parameters
        ----------
        workflow_run_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.cancel_workflow_run(
                workflow_run_id="workflow_run_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/workflows/runs/{jsonable_encoder(workflow_run_id)}/cancel",
            method="POST",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def retry_webhook(
        self,
        task_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskResponse:
        """
        Parameters
        ----------
        task_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskResponse
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.retry_webhook(
                task_id="task_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/tasks/{jsonable_encoder(task_id)}/retry_webhook",
            method="POST",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TaskResponse,
                    parse_obj_as(
                        type_=TaskResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_task_internal(
        self,
        task_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Task]:
        """
        Get all tasks.
        :param page: Starting page, defaults to 1
        :param page_size:
        :return: List of tasks with pagination without steps populated. Steps can be populated by calling the
            get_agent_task endpoint.

        Parameters
        ----------
        task_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Task]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_task_internal(
                task_id="task_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/internal/tasks/{jsonable_encoder(task_id)}",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Task],
                    parse_obj_as(
                        type_=typing.List[Task],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_tasks_internal(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Task]:
        """
        Get all tasks.
        :param page: Starting page, defaults to 1
        :param page_size: Page size, defaults to 10
        :return: List of tasks with pagination without steps populated. Steps can be populated by calling the
            get_agent_task endpoint.

        Parameters
        ----------
        page : typing.Optional[int]

        page_size : typing.Optional[int]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Task]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_tasks_internal()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/internal/tasks",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Task],
                    parse_obj_as(
                        type_=typing.List[Task],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_entity_artifacts(
        self,
        entity_type: EntityType,
        entity_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Artifact]:
        """
        Get all artifacts for an entity (step, task, workflow_run).

        Args:
            entity_type: Type of entity to fetch artifacts for
            entity_id: ID of the entity
            current_org: Current organization from auth

        Returns:
            List of artifacts for the entity

        Raises:
            HTTPException: If entity is not supported

        Parameters
        ----------
        entity_type : EntityType

        entity_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Artifact]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_entity_artifacts(
                entity_type="step",
                entity_id="entity_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/{jsonable_encoder(entity_type)}/{jsonable_encoder(entity_id)}/artifacts",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Artifact],
                    parse_obj_as(
                        type_=typing.List[Artifact],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_task_step_artifacts(
        self,
        task_id: str,
        step_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Artifact]:
        """
        Get all artifacts for a list of steps.
        :param task_id:
        :param step_id:
        :return: List of artifacts for a list of steps.

        Parameters
        ----------
        task_id : str

        step_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Artifact]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_task_step_artifacts(
                task_id="task_id",
                step_id="step_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/tasks/{jsonable_encoder(task_id)}/steps/{jsonable_encoder(step_id)}/artifacts",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Artifact],
                    parse_obj_as(
                        type_=typing.List[Artifact],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_task_actions(
        self,
        task_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Action]:
        """
        Parameters
        ----------
        task_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Action]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_task_actions(
                task_id="task_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/tasks/{jsonable_encoder(task_id)}/actions",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Action],
                    parse_obj_as(
                        type_=typing.List[Action],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def execute_workflow(
        self,
        workflow_id: str,
        *,
        version: typing.Optional[int] = None,
        template: typing.Optional[bool] = None,
        api_key: typing.Optional[str] = None,
        max_steps_override: typing.Optional[int] = None,
        authorization: typing.Optional[str] = None,
        data: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        proxy_location: typing.Optional[ProxyLocation] = OMIT,
        webhook_callback_url: typing.Optional[str] = OMIT,
        totp_verification_url: typing.Optional[str] = OMIT,
        totp_identifier: typing.Optional[str] = OMIT,
        browser_session_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> RunWorkflowResponse:
        """
        Parameters
        ----------
        workflow_id : str

        version : typing.Optional[int]

        template : typing.Optional[bool]

        api_key : typing.Optional[str]

        max_steps_override : typing.Optional[int]

        authorization : typing.Optional[str]

        data : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        proxy_location : typing.Optional[ProxyLocation]

        webhook_callback_url : typing.Optional[str]

        totp_verification_url : typing.Optional[str]

        totp_identifier : typing.Optional[str]

        browser_session_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        RunWorkflowResponse
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.execute_workflow(
                workflow_id="workflow_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/workflows/{jsonable_encoder(workflow_id)}/run",
            method="POST",
            params={
                "version": version,
                "template": template,
            },
            json={
                "data": data,
                "proxy_location": proxy_location,
                "webhook_callback_url": webhook_callback_url,
                "totp_verification_url": totp_verification_url,
                "totp_identifier": totp_identifier,
                "browser_session_id": browser_session_id,
            },
            headers={
                "content-type": "application/json",
                "x-api-key": str(api_key) if api_key is not None else None,
                "x-max-steps-override": str(max_steps_override) if max_steps_override is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    RunWorkflowResponse,
                    parse_obj_as(
                        type_=RunWorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_workflow_runs(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        status: typing.Optional[typing.Union[WorkflowRunStatus, typing.Sequence[WorkflowRunStatus]]] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[WorkflowRun]:
        """
        Parameters
        ----------
        page : typing.Optional[int]

        page_size : typing.Optional[int]

        status : typing.Optional[typing.Union[WorkflowRunStatus, typing.Sequence[WorkflowRunStatus]]]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WorkflowRun]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_workflow_runs()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/workflows/runs",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
                "status": status,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WorkflowRun],
                    parse_obj_as(
                        type_=typing.List[WorkflowRun],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_workflow_runs_for_workflow_permanent_id(
        self,
        workflow_permanent_id: str,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        status: typing.Optional[typing.Union[WorkflowRunStatus, typing.Sequence[WorkflowRunStatus]]] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[WorkflowRun]:
        """
        Parameters
        ----------
        workflow_permanent_id : str

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        status : typing.Optional[typing.Union[WorkflowRunStatus, typing.Sequence[WorkflowRunStatus]]]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WorkflowRun]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_workflow_runs_for_workflow_permanent_id(
                workflow_permanent_id="workflow_permanent_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/workflows/{jsonable_encoder(workflow_permanent_id)}/runs",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
                "status": status,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WorkflowRun],
                    parse_obj_as(
                        type_=typing.List[WorkflowRun],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_workflow_run(
        self,
        workflow_id: str,
        workflow_run_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        workflow_id : str

        workflow_run_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_workflow_run(
                workflow_id="workflow_id",
                workflow_run_id="workflow_run_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/workflows/{jsonable_encoder(workflow_id)}/runs/{jsonable_encoder(workflow_run_id)}",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_workflow_run_timeline(
        self,
        workflow_run_id: str,
        workflow_id: str,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[WorkflowRunTimeline]:
        """
        Parameters
        ----------
        workflow_run_id : str

        workflow_id : str

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WorkflowRunTimeline]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_workflow_run_timeline(
                workflow_run_id="workflow_run_id",
                workflow_id="workflow_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/workflows/{jsonable_encoder(workflow_id)}/runs/{jsonable_encoder(workflow_run_id)}/timeline",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WorkflowRunTimeline],
                    parse_obj_as(
                        type_=typing.List[WorkflowRunTimeline],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_workflow_run_by_run_id(
        self,
        workflow_run_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowRunResponse:
        """
        Parameters
        ----------
        workflow_run_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowRunResponse
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_workflow_run_by_run_id(
                workflow_run_id="workflow_run_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/workflows/runs/{jsonable_encoder(workflow_run_id)}",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WorkflowRunResponse,
                    parse_obj_as(
                        type_=WorkflowRunResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_workflows(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        only_saved_tasks: typing.Optional[bool] = None,
        only_workflows: typing.Optional[bool] = None,
        title: typing.Optional[str] = None,
        template: typing.Optional[bool] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Workflow]:
        """
        Get all workflows with the latest version for the organization.

        Parameters
        ----------
        page : typing.Optional[int]

        page_size : typing.Optional[int]

        only_saved_tasks : typing.Optional[bool]

        only_workflows : typing.Optional[bool]

        title : typing.Optional[str]

        template : typing.Optional[bool]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Workflow]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_workflows()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/workflows",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
                "only_saved_tasks": only_saved_tasks,
                "only_workflows": only_workflows,
                "title": title,
                "template": template,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Workflow],
                    parse_obj_as(
                        type_=typing.List[Workflow],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_workflow(
        self,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Workflow:
        """
        Parameters
        ----------
        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Workflow
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.create_workflow()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/workflows",
            method="POST",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Workflow,
                    parse_obj_as(
                        type_=Workflow,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_workflow(
        self,
        workflow_permanent_id: str,
        *,
        version: typing.Optional[int] = None,
        template: typing.Optional[bool] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Workflow:
        """
        Parameters
        ----------
        workflow_permanent_id : str

        version : typing.Optional[int]

        template : typing.Optional[bool]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Workflow
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_workflow(
                workflow_permanent_id="workflow_permanent_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/workflows/{jsonable_encoder(workflow_permanent_id)}",
            method="GET",
            params={
                "version": version,
                "template": template,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Workflow,
                    parse_obj_as(
                        type_=Workflow,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_workflow(
        self,
        workflow_permanent_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Workflow:
        """
        Parameters
        ----------
        workflow_permanent_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Workflow
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.update_workflow(
                workflow_permanent_id="workflow_permanent_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/workflows/{jsonable_encoder(workflow_permanent_id)}",
            method="PUT",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Workflow,
                    parse_obj_as(
                        type_=Workflow,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_workflow(
        self,
        workflow_permanent_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Parameters
        ----------
        workflow_permanent_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.delete_workflow(
                workflow_permanent_id="workflow_permanent_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/workflows/{jsonable_encoder(workflow_permanent_id)}",
            method="DELETE",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_workflows(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        only_saved_tasks: typing.Optional[bool] = None,
        only_workflows: typing.Optional[bool] = None,
        title: typing.Optional[str] = None,
        template: typing.Optional[bool] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Workflow]:
        """
        Get all workflows with the latest version for the organization.

        Parameters
        ----------
        page : typing.Optional[int]

        page_size : typing.Optional[int]

        only_saved_tasks : typing.Optional[bool]

        only_workflows : typing.Optional[bool]

        title : typing.Optional[str]

        template : typing.Optional[bool]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Workflow]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.list_workflows()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/workflows/",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
                "only_saved_tasks": only_saved_tasks,
                "only_workflows": only_workflows,
                "title": title,
                "template": template,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Workflow],
                    parse_obj_as(
                        type_=typing.List[Workflow],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def make_ai_suggestion(
        self,
        *,
        input: str,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        context: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AiSuggestionBase:
        """
        Parameters
        ----------
        input : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        context : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AiSuggestionBase
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.make_ai_suggestion(
                input="input",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/suggest/data_schema/",
            method="POST",
            json={
                "input": input,
                "context": context,
            },
            headers={
                "content-type": "application/json",
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AiSuggestionBase,
                    parse_obj_as(
                        type_=AiSuggestionBase,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def generate_task(
        self,
        *,
        prompt: str,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskGeneration:
        """
        Parameters
        ----------
        prompt : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskGeneration
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.generate_task(
                prompt="prompt",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/generate/task/",
            method="POST",
            json={
                "prompt": prompt,
            },
            headers={
                "content-type": "application/json",
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TaskGeneration,
                    parse_obj_as(
                        type_=TaskGeneration,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_organizations(
        self,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetOrganizationsResponse:
        """
        Parameters
        ----------
        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetOrganizationsResponse
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_organizations()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/organizations",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetOrganizationsResponse,
                    parse_obj_as(
                        type_=GetOrganizationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_organization(
        self,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        max_steps_per_run: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Organization:
        """
        Parameters
        ----------
        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        max_steps_per_run : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Organization
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.update_organization()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/organizations",
            method="PUT",
            json={
                "max_steps_per_run": max_steps_per_run,
            },
            headers={
                "content-type": "application/json",
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Organization,
                    parse_obj_as(
                        type_=Organization,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_org_api_keys(
        self,
        organization_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetOrganizationApiKeysResponse:
        """
        Parameters
        ----------
        organization_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetOrganizationApiKeysResponse
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_org_api_keys(
                organization_id="organization_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/organizations/{jsonable_encoder(organization_id)}/apikeys",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetOrganizationApiKeysResponse,
                    parse_obj_as(
                        type_=GetOrganizationApiKeysResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def upload_file(
        self,
        *,
        file: core.File,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.upload_file()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/upload_file",
            method="POST",
            data={},
            files={
                "file": file,
            },
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_browser_session_by_id(
        self,
        browser_session_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BrowserSessionResponse:
        """
        Parameters
        ----------
        browser_session_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BrowserSessionResponse
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_browser_session_by_id(
                browser_session_id="browser_session_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/browser_sessions/{jsonable_encoder(browser_session_id)}",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BrowserSessionResponse,
                    parse_obj_as(
                        type_=BrowserSessionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_browser_sessions(
        self,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[BrowserSessionResponse]:
        """
        Get all active browser sessions for the organization

        Parameters
        ----------
        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[BrowserSessionResponse]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_browser_sessions()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/browser_sessions",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[BrowserSessionResponse],
                    parse_obj_as(
                        type_=typing.List[BrowserSessionResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_browser_session(
        self,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BrowserSessionResponse:
        """
        Parameters
        ----------
        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BrowserSessionResponse
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.create_browser_session()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/browser_sessions",
            method="POST",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BrowserSessionResponse,
                    parse_obj_as(
                        type_=BrowserSessionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def close_browser_sessions(
        self,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Parameters
        ----------
        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.close_browser_sessions()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/browser_sessions/close",
            method="POST",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def close_browser_session(
        self,
        session_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Parameters
        ----------
        session_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.close_browser_session(
                session_id="session_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/browser_sessions/{jsonable_encoder(session_id)}/close",
            method="POST",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def observer_task_v_2(
        self,
        *,
        user_prompt: str,
        max_iterations_override: typing.Optional[int] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        url: typing.Optional[str] = OMIT,
        browser_session_id: typing.Optional[str] = OMIT,
        webhook_callback_url: typing.Optional[str] = OMIT,
        totp_verification_url: typing.Optional[str] = OMIT,
        totp_identifier: typing.Optional[str] = OMIT,
        proxy_location: typing.Optional[ProxyLocation] = OMIT,
        publish_workflow: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        user_prompt : str

        max_iterations_override : typing.Optional[int]

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        url : typing.Optional[str]

        browser_session_id : typing.Optional[str]

        webhook_callback_url : typing.Optional[str]

        totp_verification_url : typing.Optional[str]

        totp_identifier : typing.Optional[str]

        proxy_location : typing.Optional[ProxyLocation]

        publish_workflow : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.observer_task_v_2(
                user_prompt="user_prompt",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v2/tasks",
            method="POST",
            json={
                "user_prompt": user_prompt,
                "url": url,
                "browser_session_id": browser_session_id,
                "webhook_callback_url": webhook_callback_url,
                "totp_verification_url": totp_verification_url,
                "totp_identifier": totp_identifier,
                "proxy_location": proxy_location,
                "publish_workflow": publish_workflow,
            },
            headers={
                "content-type": "application/json",
                "x-max-iterations-override": str(max_iterations_override)
                if max_iterations_override is not None
                else None,
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_observer_task_v_2(
        self,
        task_id: str,
        *,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        task_id : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_observer_task_v_2(
                task_id="task_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v2/tasks/{jsonable_encoder(task_id)}",
            method="GET",
            headers={
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def run_observer_task_v_2(
        self,
        *,
        user_prompt: str,
        max_iterations_override: typing.Optional[int] = None,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        url: typing.Optional[str] = OMIT,
        browser_session_id: typing.Optional[str] = OMIT,
        webhook_callback_url: typing.Optional[str] = OMIT,
        totp_verification_url: typing.Optional[str] = OMIT,
        totp_identifier: typing.Optional[str] = OMIT,
        proxy_location: typing.Optional[ProxyLocation] = OMIT,
        publish_workflow: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
        timeout_seconds: int = 600,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        observer_task = await self.observer_task_v_2(
            user_prompt=user_prompt,
            max_iterations_override=max_iterations_override,
            api_key=api_key,
            authorization=authorization,
            url=url,
            browser_session_id=browser_session_id,
            webhook_callback_url=webhook_callback_url,
            totp_verification_url=totp_verification_url,
            totp_identifier=totp_identifier,
            proxy_location=proxy_location,
            publish_workflow=publish_workflow,
            request_options=request_options,
        )
        task_id = observer_task.get("task_id")
        async with asyncio.timeout(timeout_seconds):
            while True:
                task = await self.get_observer_task_v_2(
                    str(task_id),
                    api_key=api_key,
                    authorization=authorization,
                    request_options=request_options,
                )
                if str(task.get("status")) in ["timed_out", "failed", "terminated", "completed", "canceled"]:
                    return task
                await asyncio.sleep(1)

    async def save_totp_code(
        self,
        *,
        totp_identifier: str,
        content: str,
        api_key: typing.Optional[str] = None,
        authorization: typing.Optional[str] = None,
        task_id: typing.Optional[str] = OMIT,
        workflow_id: typing.Optional[str] = OMIT,
        source: typing.Optional[str] = OMIT,
        expired_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TotpCode:
        """
        Parameters
        ----------
        totp_identifier : str

        content : str

        api_key : typing.Optional[str]

        authorization : typing.Optional[str]

        task_id : typing.Optional[str]

        workflow_id : typing.Optional[str]

        source : typing.Optional[str]

        expired_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TotpCode
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.save_totp_code(
                totp_identifier="totp_identifier",
                content="content",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/totp",
            method="POST",
            json={
                "totp_identifier": totp_identifier,
                "task_id": task_id,
                "workflow_id": workflow_id,
                "source": source,
                "content": content,
                "expired_at": expired_at,
            },
            headers={
                "content-type": "application/json",
                "x-api-key": str(api_key) if api_key is not None else None,
                "authorization": str(authorization) if authorization is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TotpCode,
                    parse_obj_as(
                        type_=TotpCode,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_eval_workflow_runs(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[WorkflowRun]:
        """
        Parameters
        ----------
        page : typing.Optional[int]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WorkflowRun]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_eval_workflow_runs()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/eval/workflows/runs",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WorkflowRun],
                    parse_obj_as(
                        type_=typing.List[WorkflowRun],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_eval_workflow_run(
        self, workflow_id: str, workflow_run_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        workflow_id : str

        workflow_run_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_eval_workflow_run(
                workflow_id="workflow_id",
                workflow_run_id="workflow_run_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/eval/workflows/{jsonable_encoder(workflow_id)}/runs/{jsonable_encoder(workflow_run_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, typing.Optional[typing.Any]],
                    parse_obj_as(
                        type_=typing.Dict[str, typing.Optional[typing.Any]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_eval_workflow_run_timeline(
        self, workflow_run_id: str, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[WorkflowRunTimeline]:
        """
        Parameters
        ----------
        workflow_run_id : str

        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WorkflowRunTimeline]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_eval_workflow_run_timeline(
                workflow_run_id="workflow_run_id",
                workflow_id="workflow_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/eval/workflows/{jsonable_encoder(workflow_id)}/runs/{jsonable_encoder(workflow_run_id)}/timeline/",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WorkflowRunTimeline],
                    parse_obj_as(
                        type_=typing.List[WorkflowRunTimeline],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_workflow_run_timeline(
        self, workflow_run_id: str, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[WorkflowRunTimeline]:
        """
        Parameters
        ----------
        workflow_run_id : str

        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WorkflowRunTimeline]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.list_workflow_run_timeline(
                workflow_run_id="workflow_run_id",
                workflow_id="workflow_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/eval/workflows/{jsonable_encoder(workflow_id)}/runs/{jsonable_encoder(workflow_run_id)}/timeline",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WorkflowRunTimeline],
                    parse_obj_as(
                        type_=typing.List[WorkflowRunTimeline],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_eval_workflow_run_by_run_id(
        self, workflow_run_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> WorkflowRunResponse:
        """
        Parameters
        ----------
        workflow_run_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowRunResponse
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_eval_workflow_run_by_run_id(
                workflow_run_id="workflow_run_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/eval/workflows/runs/{jsonable_encoder(workflow_run_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WorkflowRunResponse,
                    parse_obj_as(
                        type_=WorkflowRunResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_eval_workflow(
        self,
        workflow_permanent_id: str,
        *,
        version: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Workflow:
        """
        Parameters
        ----------
        workflow_permanent_id : str

        version : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Workflow
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_eval_workflow(
                workflow_permanent_id="workflow_permanent_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/eval/workflows/{jsonable_encoder(workflow_permanent_id)}/",
            method="GET",
            params={
                "version": version,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Workflow,
                    parse_obj_as(
                        type_=Workflow,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_eval_workflow_runs_for_workflow_permanent_id(
        self,
        workflow_permanent_id: str,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[WorkflowRun]:
        """
        Parameters
        ----------
        workflow_permanent_id : str

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WorkflowRun]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_eval_workflow_runs_for_workflow_permanent_id(
                workflow_permanent_id="workflow_permanent_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/eval/workflows/{jsonable_encoder(workflow_permanent_id)}/runs",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WorkflowRun],
                    parse_obj_as(
                        type_=typing.List[WorkflowRun],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_eval_entity_artifacts(
        self, entity_type: EntityType, entity_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[Artifact]:
        """
        Get all artifacts for an entity (step, task, workflow_run).

        Args:
            entity_type: Type of entity to fetch artifacts for
            entity_id: ID of the entity
            current_org: Current organization from auth

        Returns:
            List of artifacts for the entity

        Raises:
            HTTPException: If entity is not supported

        Parameters
        ----------
        entity_type : EntityType

        entity_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Artifact]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_eval_entity_artifacts(
                entity_type="step",
                entity_id="entity_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/eval/{jsonable_encoder(entity_type)}/{jsonable_encoder(entity_id)}/artifacts",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Artifact],
                    parse_obj_as(
                        type_=typing.List[Artifact],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_eval_task_actions(
        self, task_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[Action]:
        """
        Parameters
        ----------
        task_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Action]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_eval_task_actions(
                task_id="task_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/eval/tasks/{jsonable_encoder(task_id)}/actions",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Action],
                    parse_obj_as(
                        type_=typing.List[Action],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_eval_task_step_artifacts(
        self, task_id: str, step_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[Artifact]:
        """
        Get all artifacts for a list of steps.
        :param task_id:
        :param step_id:
        :return: List of artifacts for a list of steps.

        Parameters
        ----------
        task_id : str

        step_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Artifact]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_eval_task_step_artifacts(
                task_id="task_id",
                step_id="step_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/eval/tasks/{jsonable_encoder(task_id)}/steps/{jsonable_encoder(step_id)}/artifacts",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Artifact],
                    parse_obj_as(
                        type_=typing.List[Artifact],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_eval_task_steps(
        self, task_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[Step]:
        """
        Get all steps for a task.
        :param task_id:
        :return: List of steps for a task with pagination.

        Parameters
        ----------
        task_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Step]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_eval_task_steps(
                task_id="task_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/eval/tasks/{jsonable_encoder(task_id)}/steps",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Step],
                    parse_obj_as(
                        type_=typing.List[Step],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_agent_tasks(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        task_status: typing.Optional[typing.Union[TaskStatus, typing.Sequence[TaskStatus]]] = None,
        workflow_run_id: typing.Optional[str] = None,
        only_standalone_tasks: typing.Optional[bool] = None,
        application: typing.Optional[str] = None,
        sort: typing.Optional[OrderBy] = None,
        order: typing.Optional[SortDirection] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Task]:
        """
        Get all tasks.
        :param page: Starting page, defaults to 1
        :param page_size: Page size, defaults to 10
        :param task_status: Task status filter
        :param workflow_run_id: Workflow run id filter
        :param only_standalone_tasks: Only standalone tasks, tasks which are part of a workflow run will be filtered out
        :param order: Direction to sort by, ascending or descending
        :param sort: Column to sort by, created_at or modified_at
        :return: List of tasks with pagination without steps populated. Steps can be populated by calling the
            get_agent_task endpoint.

        Parameters
        ----------
        page : typing.Optional[int]

        page_size : typing.Optional[int]

        task_status : typing.Optional[typing.Union[TaskStatus, typing.Sequence[TaskStatus]]]

        workflow_run_id : typing.Optional[str]

        only_standalone_tasks : typing.Optional[bool]

        application : typing.Optional[str]

        sort : typing.Optional[OrderBy]

        order : typing.Optional[SortDirection]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Task]
            Successful Response

        Examples
        --------
        import asyncio

        from skyverndocs import AsyncSkyvern

        client = AsyncSkyvern()


        async def main() -> None:
            await client.agent.get_agent_tasks()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/eval/tasks",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
                "task_status": task_status,
                "workflow_run_id": workflow_run_id,
                "only_standalone_tasks": only_standalone_tasks,
                "application": application,
                "sort": sort,
                "order": order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Task],
                    parse_obj_as(
                        type_=typing.List[Task],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
