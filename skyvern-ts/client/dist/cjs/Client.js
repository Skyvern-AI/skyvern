"use strict";
// This file was auto-generated by Fern from our API Definition.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SkyvernClient = void 0;
const Skyvern = __importStar(require("./api/index.js"));
const Client_js_1 = require("./api/resources/scripts/client/Client.js");
const headers_js_1 = require("./core/headers.js");
const core = __importStar(require("./core/index.js"));
const environments = __importStar(require("./environments.js"));
const errors = __importStar(require("./errors/index.js"));
class SkyvernClient {
    constructor(_options = {}) {
        this._options = Object.assign(Object.assign({}, _options), { headers: (0, headers_js_1.mergeHeaders)({
                "x-api-key": _options === null || _options === void 0 ? void 0 : _options.apiKey,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "@skyvern-fern/api-sdk",
                "X-Fern-SDK-Version": "0.0.74",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
            }, _options === null || _options === void 0 ? void 0 : _options.headers) });
    }
    get scripts() {
        var _a;
        return ((_a = this._scripts) !== null && _a !== void 0 ? _a : (this._scripts = new Client_js_1.Scripts(this._options)));
    }
    /**
     * Run a task
     *
     * @param {Skyvern.RunTaskRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.BadRequestError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.runTask({
     *         "x-user-agent": "x-user-agent",
     *         body: {
     *             prompt: "Find the top 3 posts on Hacker News."
     *         }
     *     })
     */
    runTask(request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__runTask(request, requestOptions));
    }
    __runTask(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const { "x-user-agent": userAgent, body: _body } = request;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-user-agent": userAgent != null ? userAgent : undefined, "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, "v1/run/tasks"),
                method: "POST",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: _body,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Skyvern.BadRequestError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/run/tasks.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Run a workflow
     *
     * @param {Skyvern.RunWorkflowRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.BadRequestError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.runWorkflow({
     *         "x-max-steps-override": 1,
     *         "x-user-agent": "x-user-agent",
     *         template: true,
     *         body: {
     *             workflow_id: "wpid_123"
     *         }
     *     })
     */
    runWorkflow(request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__runWorkflow(request, requestOptions));
    }
    __runWorkflow(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const { template, "x-max-steps-override": maxStepsOverride, "x-user-agent": userAgent, body: _body } = request;
            const _queryParams = {};
            if (template != null) {
                _queryParams.template = template.toString();
            }
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-max-steps-override": maxStepsOverride != null ? maxStepsOverride.toString() : undefined, "x-user-agent": userAgent != null ? userAgent : undefined, "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, "v1/run/workflows"),
                method: "POST",
                headers: _headers,
                contentType: "application/json",
                queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
                requestType: "json",
                body: _body,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Skyvern.BadRequestError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/run/workflows.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Get run information (task run, workflow run)
     *
     * @param {string} runId - The id of the task run or the workflow run.
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.NotFoundError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getRun("tsk_123")
     */
    getRun(runId, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__getRun(runId, requestOptions));
    }
    __getRun(runId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, `v1/runs/${core.url.encodePathParam(runId)}`),
                method: "GET",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 404:
                        throw new Skyvern.NotFoundError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/runs/{run_id}.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Cancel a run (task or workflow)
     *
     * @param {string} runId - The id of the task run or the workflow run to cancel.
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.cancelRun("run_id")
     */
    cancelRun(runId, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__cancelRun(runId, requestOptions));
    }
    __cancelRun(runId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, `v1/runs/${core.url.encodePathParam(runId)}/cancel`),
                method: "POST",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/runs/{run_id}/cancel.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Get all workflows with the latest version for the organization.
     *
     * Search semantics:
     * - If `search_key` is provided, its value is used as a unified search term for both
     *   `workflows.title` and workflow parameter metadata (key, description, and default_value for
     *   `WorkflowParameterModel`).
     * - Falls back to deprecated `title` (title-only search) if `search_key` is not provided.
     * - Parameter metadata search excludes soft-deleted parameter rows across all parameter tables.
     *
     * @param {Skyvern.GetWorkflowsRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getWorkflows({
     *         page: 1,
     *         page_size: 1,
     *         only_saved_tasks: true,
     *         only_workflows: true,
     *         search_key: "search_key",
     *         title: "title",
     *         template: true
     *     })
     */
    getWorkflows(request = {}, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__getWorkflows(request, requestOptions));
    }
    __getWorkflows() {
        return __awaiter(this, arguments, void 0, function* (request = {}, requestOptions) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const { page, page_size: pageSize, only_saved_tasks: onlySavedTasks, only_workflows: onlyWorkflows, search_key: searchKey, title, template, } = request;
            const _queryParams = {};
            if (page != null) {
                _queryParams.page = page.toString();
            }
            if (pageSize != null) {
                _queryParams.page_size = pageSize.toString();
            }
            if (onlySavedTasks != null) {
                _queryParams.only_saved_tasks = onlySavedTasks.toString();
            }
            if (onlyWorkflows != null) {
                _queryParams.only_workflows = onlyWorkflows.toString();
            }
            if (searchKey != null) {
                _queryParams.search_key = searchKey;
            }
            if (title != null) {
                _queryParams.title = title;
            }
            if (template != null) {
                _queryParams.template = template.toString();
            }
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, "v1/workflows"),
                method: "GET",
                headers: _headers,
                queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/workflows.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Create a new workflow
     *
     * @param {Skyvern.WorkflowRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.createWorkflow({})
     */
    createWorkflow(request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__createWorkflow(request, requestOptions));
    }
    __createWorkflow(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, "v1/workflows"),
                method: "POST",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: request,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/workflows.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Update a workflow
     *
     * @param {string} workflowId - The ID of the workflow to update. Workflow ID starts with `wpid_`.
     * @param {Skyvern.WorkflowRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.updateWorkflow("wpid_123", {})
     */
    updateWorkflow(workflowId, request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__updateWorkflow(workflowId, request, requestOptions));
    }
    __updateWorkflow(workflowId, request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, `v1/workflows/${core.url.encodePathParam(workflowId)}`),
                method: "POST",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: request,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/workflows/{workflow_id}.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Delete a workflow
     *
     * @param {string} workflowId - The ID of the workflow to delete. Workflow ID starts with `wpid_`.
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.deleteWorkflow("wpid_123")
     */
    deleteWorkflow(workflowId, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__deleteWorkflow(workflowId, requestOptions));
    }
    __deleteWorkflow(workflowId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, `v1/workflows/${core.url.encodePathParam(workflowId)}/delete`),
                method: "POST",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/workflows/{workflow_id}/delete.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Get an artifact
     *
     * @param {string} artifactId
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.NotFoundError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getArtifact("artifact_id")
     */
    getArtifact(artifactId, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__getArtifact(artifactId, requestOptions));
    }
    __getArtifact(artifactId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, `v1/artifacts/${core.url.encodePathParam(artifactId)}`),
                method: "GET",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 404:
                        throw new Skyvern.NotFoundError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/artifacts/{artifact_id}.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Get artifacts for a run
     *
     * @param {string} runId - The id of the task run or the workflow run.
     * @param {Skyvern.GetRunArtifactsRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getRunArtifacts("run_id")
     */
    getRunArtifacts(runId, request = {}, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__getRunArtifacts(runId, request, requestOptions));
    }
    __getRunArtifacts(runId_1) {
        return __awaiter(this, arguments, void 0, function* (runId, request = {}, requestOptions) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const { artifact_type: artifactType } = request;
            const _queryParams = {};
            if (artifactType != null) {
                if (Array.isArray(artifactType)) {
                    _queryParams.artifact_type = artifactType.map((item) => item);
                }
                else {
                    _queryParams.artifact_type = artifactType;
                }
            }
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, `v1/runs/${core.url.encodePathParam(runId)}/artifacts`),
                method: "GET",
                headers: _headers,
                queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/runs/{run_id}/artifacts.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Retry sending the webhook for a run
     *
     * @param {string} runId - The id of the task run or the workflow run.
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.retryRunWebhook("tsk_123")
     */
    retryRunWebhook(runId, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__retryRunWebhook(runId, requestOptions));
    }
    __retryRunWebhook(runId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, `v1/runs/${core.url.encodePathParam(runId)}/retry_webhook`),
                method: "POST",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/runs/{run_id}/retry_webhook.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Get timeline for a run (workflow run or task_v2 run)
     *
     * @param {string} runId - The id of the workflow run or task_v2 run.
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.BadRequestError}
     * @throws {@link Skyvern.NotFoundError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getRunTimeline("wr_123")
     */
    getRunTimeline(runId, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__getRunTimeline(runId, requestOptions));
    }
    __getRunTimeline(runId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, `v1/runs/${core.url.encodePathParam(runId)}/timeline`),
                method: "GET",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Skyvern.BadRequestError(_response.error.body, _response.rawResponse);
                    case 404:
                        throw new Skyvern.NotFoundError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/runs/{run_id}/timeline.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Get all active browser sessions for the organization
     *
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.ForbiddenError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getBrowserSessions()
     */
    getBrowserSessions(requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__getBrowserSessions(requestOptions));
    }
    __getBrowserSessions(requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, "v1/browser_sessions"),
                method: "GET",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 403:
                        throw new Skyvern.ForbiddenError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/browser_sessions.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Create a browser session that persists across multiple runs
     *
     * @param {Skyvern.CreateBrowserSessionRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.ForbiddenError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.createBrowserSession()
     */
    createBrowserSession(request = {}, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__createBrowserSession(request, requestOptions));
    }
    __createBrowserSession() {
        return __awaiter(this, arguments, void 0, function* (request = {}, requestOptions) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, "v1/browser_sessions"),
                method: "POST",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: request,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 403:
                        throw new Skyvern.ForbiddenError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/browser_sessions.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Close a session. Once closed, the session cannot be used again.
     *
     * @param {string} browserSessionId - The ID of the browser session to close. completed_at will be set when the browser session is closed. browser_session_id starts with `pbs_`
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.ForbiddenError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.closeBrowserSession("pbs_123456")
     */
    closeBrowserSession(browserSessionId, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__closeBrowserSession(browserSessionId, requestOptions));
    }
    __closeBrowserSession(browserSessionId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, `v1/browser_sessions/${core.url.encodePathParam(browserSessionId)}/close`),
                method: "POST",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 403:
                        throw new Skyvern.ForbiddenError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/browser_sessions/{browser_session_id}/close.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Get details about a specific browser session, including the browser address for cdp connection.
     *
     * @param {string} browserSessionId - The ID of the browser session. browser_session_id starts with `pbs_`
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.ForbiddenError}
     * @throws {@link Skyvern.NotFoundError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getBrowserSession("pbs_123456")
     */
    getBrowserSession(browserSessionId, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__getBrowserSession(browserSessionId, requestOptions));
    }
    __getBrowserSession(browserSessionId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, `v1/browser_sessions/${core.url.encodePathParam(browserSessionId)}`),
                method: "GET",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 403:
                        throw new Skyvern.ForbiddenError(_response.error.body, _response.rawResponse);
                    case 404:
                        throw new Skyvern.NotFoundError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/browser_sessions/{browser_session_id}.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Forward a TOTP (2FA, MFA) email or sms message containing the code to Skyvern. This endpoint stores the code in database so that Skyvern can use it while running tasks/workflows.
     *
     * @param {Skyvern.TotpCodeCreate} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.sendTotpCode({
     *         totp_identifier: "john.doe@example.com",
     *         content: "Hello, your verification code is 123456"
     *     })
     */
    sendTotpCode(request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__sendTotpCode(request, requestOptions));
    }
    __sendTotpCode(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, "v1/credentials/totp"),
                method: "POST",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: request,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/credentials/totp.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Retrieves a paginated list of credentials for the current organization
     *
     * @param {Skyvern.GetCredentialsRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getCredentials({
     *         page: 1,
     *         page_size: 10
     *     })
     */
    getCredentials(request = {}, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__getCredentials(request, requestOptions));
    }
    __getCredentials() {
        return __awaiter(this, arguments, void 0, function* (request = {}, requestOptions) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const { page, page_size: pageSize } = request;
            const _queryParams = {};
            if (page != null) {
                _queryParams.page = page.toString();
            }
            if (pageSize != null) {
                _queryParams.page_size = pageSize.toString();
            }
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, "v1/credentials"),
                method: "GET",
                headers: _headers,
                queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/credentials.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Creates a new credential for the current organization
     *
     * @param {Skyvern.CreateCredentialRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.createCredential({
     *         name: "My Credential",
     *         credential_type: "password",
     *         credential: {
     *             password: "securepassword123",
     *             username: "user@example.com",
     *             totp: "JBSWY3DPEHPK3PXP"
     *         }
     *     })
     */
    createCredential(request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__createCredential(request, requestOptions));
    }
    __createCredential(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, "v1/credentials"),
                method: "POST",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: request,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/credentials.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Deletes a specific credential by its ID
     *
     * @param {string} credentialId - The unique identifier of the credential to delete
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.deleteCredential("cred_1234567890")
     */
    deleteCredential(credentialId, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__deleteCredential(credentialId, requestOptions));
    }
    __deleteCredential(credentialId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, `v1/credentials/${core.url.encodePathParam(credentialId)}/delete`),
                method: "POST",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: undefined, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/credentials/{credential_id}/delete.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Retrieves a specific credential by its ID
     *
     * @param {string} credentialId - The unique identifier of the credential
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getCredential("cred_1234567890")
     */
    getCredential(credentialId, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__getCredential(credentialId, requestOptions));
    }
    __getCredential(credentialId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, `v1/credentials/${core.url.encodePathParam(credentialId)}`),
                method: "GET",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/credentials/{credential_id}.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Log in to a website using either credential stored in Skyvern, Bitwarden, 1Password, or Azure Vault
     *
     * @param {Skyvern.LoginRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.login({
     *         credential_type: "skyvern"
     *     })
     */
    login(request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__login(request, requestOptions));
    }
    __login(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, "v1/run/tasks/login"),
                method: "POST",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: request,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/run/tasks/login.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Retrieves a paginated list of scripts for the current organization
     *
     * @param {Skyvern.GetScriptsRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getScripts({
     *         page: 1,
     *         page_size: 10
     *     })
     */
    getScripts(request = {}, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__getScripts(request, requestOptions));
    }
    __getScripts() {
        return __awaiter(this, arguments, void 0, function* (request = {}, requestOptions) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const { page, page_size: pageSize } = request;
            const _queryParams = {};
            if (page != null) {
                _queryParams.page = page.toString();
            }
            if (pageSize != null) {
                _queryParams.page_size = pageSize.toString();
            }
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, "v1/scripts"),
                method: "GET",
                headers: _headers,
                queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/scripts.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Create a new script with optional files and metadata
     *
     * @param {Skyvern.CreateScriptRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.createScript()
     */
    createScript(request = {}, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__createScript(request, requestOptions));
    }
    __createScript() {
        return __awaiter(this, arguments, void 0, function* (request = {}, requestOptions) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, "v1/scripts"),
                method: "POST",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: request,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/scripts.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Retrieves a specific script by its ID
     *
     * @param {string} scriptId - The unique identifier of the script
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getScript("s_abc123")
     */
    getScript(scriptId, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__getScript(scriptId, requestOptions));
    }
    __getScript(scriptId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, `v1/scripts/${core.url.encodePathParam(scriptId)}`),
                method: "GET",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/scripts/{script_id}.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Deploy a script with updated files, creating a new version
     *
     * @param {string} scriptId - The unique identifier of the script
     * @param {Skyvern.DeployScriptRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.deployScript("s_abc123", {
     *         files: [{
     *                 path: "src/main.py",
     *                 content: "content"
     *             }]
     *     })
     */
    deployScript(scriptId, request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__deployScript(scriptId, request, requestOptions));
    }
    __deployScript(scriptId, request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const _headers = (0, headers_js_1.mergeHeaders)((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, (0, headers_js_1.mergeOnlyDefinedHeaders)(Object.assign({ "x-api-key": (_b = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiKey) !== null && _b !== void 0 ? _b : (_c = this._options) === null || _c === void 0 ? void 0 : _c.apiKey }, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.SkyvernEnvironment.Production, `v1/scripts/${core.url.encodePathParam(scriptId)}/deploy`),
                method: "POST",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: request,
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new Skyvern.UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.SkyvernError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/scripts/{script_id}/deploy.");
                case "unknown":
                    throw new errors.SkyvernError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    _getCustomAuthorizationHeaders() {
        return __awaiter(this, void 0, void 0, function* () {
            const xApiKeyValue = yield core.Supplier.get(this._options.xApiKey);
            return { "x-api-key": xApiKeyValue };
        });
    }
}
exports.SkyvernClient = SkyvernClient;
