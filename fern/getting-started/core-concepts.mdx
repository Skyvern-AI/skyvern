# Core Concepts

This page covers the foundational concepts you'll encounter when building with Skyvern.

---

## Tasks

A **Task** is a single automation job. You give Skyvern a URL and a natural language prompt describing what you want to accomplish, and it navigates the browser to complete the goal.

```python
from skyvern import Skyvern

skyvern = Skyvern(api_key="YOUR_API_KEY")

result = await skyvern.run_task(
    url="https://news.ycombinator.com",
    prompt="Find the top 3 posts on the front page",
    data_extraction_schema={
        "type": "object",
        "properties": {
            "posts": {
                "type": "array",
                "items": {"type": "string"}
            }
        }
    }
)

print(result.output)  # {"posts": ["Post 1", "Post 2", "Post 3"]}
```

**Key properties:**

| Property | Description |
|----------|-------------|
| `url` | Starting URL for the task |
| `prompt` | Natural language description of the goal |
| `data_extraction_schema` | JSON Schema defining expected output structure |
| `max_steps` | Maximum steps allowed |
| `engine` | AI model (`skyvern-2.0`, `openai-cua`, `anthropic-cua`, etc.) |
| `browser_session_id` | Run in an existing browser session |
| `webhook_url` | Callback URL for async completion |

**When to use Tasks:**
- One-off automations you won't repeat
- Quick data extraction from a single page
- Prototyping before building a workflow
- Simple goals that don't require multiple stages

For reusable, multi-step automations, use Workflows instead.

---

## Workflows

A **Workflow** is a multi-step automation composed of blocks. Unlike tasks, workflows are reusable templates that can be versioned, published, and executed repeatedly with different parameters.

```python
# Run a workflow with parameters
result = await skyvern.run_workflow(
    workflow_id="wpid_abc123",
    parameters={
        "search_query": "wireless headphones",
        "max_price": 100
    }
)

print(result.output)
```

Workflows support parameterization using Jinja syntax. Blocks can reference:
- Workflow parameters: `{{search_query}}`
- Previous block outputs: `{{extract_block.product_name}}`

```
┌─────────────────────────────────┐
│           WORKFLOW              │
├─────────────────────────────────┤
│  Block 1: Navigate to site      │
│            ↓                    │
│  Block 2: Login                 │
│            ↓                    │
│  Block 3: Extract data          │
│            ↓                    │
│  Block 4: Download file         │
└─────────────────────────────────┘
```

**When to use Workflows:**
- Automations you'll run repeatedly with different inputs
- Multi-step processes (login → navigate → extract → download)
- Team-shared automations that need version control
- Complex logic requiring loops, conditionals, or custom code

**When to use Tasks instead:**
- One-off jobs you won't repeat
- Simple single-goal automations
- Quick prototyping


---

## Blocks

**Blocks** are the building units of workflows. Each block type handles a specific automation task. Blocks execute sequentially, and each can produce outputs that subsequent blocks reference.

### Navigation & Interaction

| Block | Purpose |
|-------|---------|
| **Navigation** | Navigate toward a goal using AI—Skyvern figures out the clicks and inputs |
| **Action** | Perform a single specific action (click, type, select, upload) |
| **URL** | Navigate directly to a specific URL |
| **Login** | Authenticate using stored credentials |
| **Wait** | Pause execution for a specified duration |

### Data & Files

| Block | Purpose |
|-------|---------|
| **Extract** | Pull structured data from a page into JSON |
| **File Download** | Download files from websites |
| **File Upload** | Upload files to S3 or other destinations |
| **File Parser** | Process PDFs, CSVs, and Excel files |
| **PDF Parser** | Specialized PDF text extraction |

### Logic & Control Flow

| Block | Purpose |
|-------|---------|
| **Validation** | Assert conditions; halt workflow on failure |
| **For Loop** | Repeat a sequence of blocks over a list |
| **Code** | Execute custom Python/Playwright scripts |

### Communication

| Block | Purpose |
|-------|---------|
| **Text Prompt** | Text-only LLM prompt (no browser interaction) |
| **Send Email** | Send email messages |


---

## Runs

A **Run** is an execution instance of a task or workflow. Every time you execute a task or workflow, Skyvern creates a run to track its progress and store outputs.

```python
# Run a task synchronously (blocks until complete)
result = await skyvern.run_task(
    url="https://example.com",
    prompt="Extract the main heading"
)

print(result.run_id)   # "tsk_abc123"
print(result.status)   # "completed"
print(result.output)   # {"heading": "Welcome"}
```

**Lifecycle:**

```
created → queued → running ─┬→ completed
                            ├→ failed
                            ├→ timed_out
                            └→ canceled
```

**Run identifiers:**
- Task runs: `tsk_*` prefix
- Workflow runs: `wr_*` prefix

**Run response fields:**

| Field | Description |
|-------|-------------|
| `run_id` | Unique identifier |
| `status` | Current lifecycle state |
| `output` | Extracted data (matches your schema) |
| `recording_url` | Video of the execution |
| `screenshot_urls` | Screenshots captured during execution |
| `downloaded_files` | Files retrieved (with URLs and checksums) |
| `failure_reason` | Error details if failed |
| `step_count` | Number of steps taken |

**Billing note:** You're billed per step. Use `max_steps` to cap costs. A step is one AI decision + action cycle.

---

## Credentials

**Credentials** provide secure storage for authentication data. Skyvern encrypts credentials at rest and in transit, and injects them directly into the browser during execution—**credentials are never sent to or seen by the LLM**.

```python
# Credentials are referenced by ID in workflows, not by value
# The Login block handles injection automatically

# In the Skyvern UI or API, you create a credential:
# → credential_id: "cred_xyz789"

# Then reference it in your workflow's Login block:
# → credential_parameter: "cred_xyz789"
```

**Security model:**
1. You store credentials in Skyvern (or connect an external vault)
2. Credentials are encrypted and never logged
3. During execution, Skyvern injects values directly into form fields
4. The LLM sees only that a login happened—never the actual secrets

**Supported credential types:**
- Usernames and passwords
- TOTP codes (authenticator apps)
- SMS/email verification codes
- Credit cards (Visa, Mastercard)

**External vault integrations:**
- Bitwarden
- 1Password
- Custom HTTP APIs
- *Coming soon:* LastPass, Keeper, Azure Key Vault, AWS Secrets Manager

---

## Browser Sessions

A **Browser Session** is a live browser instance that maintains state across multiple tasks or workflow runs. The session persists cookies, local storage, authentication, and navigation history in real-time.

```python
# Create a session (lives for 60 minutes by default)
browser_session = await skyvern.create_browser_session(timeout=120)

# Run multiple tasks in the same session
await skyvern.run_task(
    url="https://example.com/login",
    prompt="Log in with the test account",
    browser_session_id=browser_session.browser_session_id
)

# Second task reuses the authenticated state
await skyvern.run_task(
    url="https://example.com/dashboard",
    prompt="Extract the account balance",
    browser_session_id=browser_session.browser_session_id
)

# Clean up
await skyvern.close_browser_session(
    browser_session_id=browser_session.browser_session_id
)
```

**When to use Browser Sessions:**
- Running multiple tasks that share authentication
- Human-in-the-loop workflows needing live intervention
- Chaining tasks without re-authenticating between each

**Session limits:**
- Timeout: 5 to 10,080 minutes (7 days max)
- Default: 60 minutes
- Available via API/SDK only (not in UI)

---

## Browser Profiles

A **Browser Profile** is a saved snapshot of browser state. Unlike sessions (which are live and temporary), profiles are persistent and reusable—perfect for skipping login steps in future runs.

```python
# Method 1: Create from a completed workflow run
run = await skyvern.run_workflow(
    workflow_id="wpid_login_flow",
    persist_browser_session=True  # Keep state after completion
)

profile = skyvern.browser_profiles.create_browser_profile(
    name="my-authenticated-profile",
    workflow_run_id=run.run_id
)

# Method 2: Create from an active session
profile = skyvern.browser_profiles.create_browser_profile(
    name="my-authenticated-profile",
    browser_session_id=browser_session.browser_session_id
)

# Use the profile in future runs (skips login entirely)
await skyvern.run_workflow(
    workflow_id="wpid_extract_data",
    browser_profile_id=profile.browser_profile_id  # Restores authenticated state
)
```

**What's saved:**
- Cookies and authentication tokens
- Local storage and session storage
- Browser preferences

**When to use Browser Profiles:**
- Workflows that run daily/weekly on the same account
- Sharing authenticated state across your team (profiles are org-scoped)
- Avoiding repeated login steps and 2FA prompts

**When to use Sessions instead:**
- You need a live, interactive browser
- State only needs to persist for the current session
- You're chaining tasks in real-time

---

## Artifacts

**Artifacts** are the outputs generated during execution. Every run produces artifacts for observability, debugging, and audit trails.

```python
# Artifacts are included in the run response
result = await skyvern.run_task(
    url="https://example.com",
    prompt="Download the quarterly report"
)

# Access artifacts directly from the result
print(result.recording_url)      # Full video of execution
print(result.screenshot_urls)    # List of screenshot URLs
print(result.downloaded_files)   # [{"url": "...", "checksum": "..."}]
```

**Artifact types:**

| Artifact | Description | Access |
|----------|-------------|--------|
| **Recordings** | End-to-end video of the entire run | `run.recording_url` |
| **Screenshots** | Captured after each action | `run.screenshot_urls` |
| **Downloaded files** | Files retrieved during execution | `run.downloaded_files` |
| **Logs** | JSON-structured logs (step, task, workflow levels) | UI → Run History |
| **HAR files** | HTTP Archive data for network debugging | UI → Run History |

**In the Skyvern UI:**
1. Go to **Run History**
2. Click on a run
3. View recordings, screenshots, and logs in the **Artifacts** tab

Artifacts are stored in your configured storage (S3, Azure Blob, or local filesystem for self-hosted).

---

## How It All Fits Together

**The execution hierarchy:**

```
WORKFLOW (reusable template)
    └── contains BLOCKS (sequential steps)
            └── produces a RUN (execution instance)
                    └── generates ARTIFACTS (recordings, screenshots, logs)
```

**State management:**

```
BROWSER SESSION (live, temporary)
    └── can be saved as → BROWSER PROFILE (persistent, reusable)
```

**Security layer:**

```
CREDENTIALS (encrypted, never exposed to LLM)
    └── injected into → LOGIN BLOCK → authenticates the browser
```

**Choosing the right approach:**

| Scenario | Use |
|----------|-----|
| One-off automation | Task |
| Reusable multi-step process | Workflow |
| Need live browser between runs | Browser Session |
| Skip login on repeated runs | Browser Profile |
| Store secrets securely | Credentials |

---

## Next Steps

- [Quickstart: Run your first task →](https://www.skyvern.com/docs/getting-started/quickstart)
- [Build your first workflow →](https://www.skyvern.com/docs/workflows/run-workflows)
- [API Reference →](https://www.skyvern.com/docs/api-reference)
