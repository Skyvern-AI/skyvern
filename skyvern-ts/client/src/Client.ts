// This file was auto-generated by Fern from our API Definition.

import * as Skyvern from "./api/index.js";
import { Scripts } from "./api/resources/scripts/client/Client.js";
import type { BaseClientOptions, BaseRequestOptions } from "./BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "./core/headers.js";
import * as core from "./core/index.js";
import * as environments from "./environments.js";
import * as errors from "./errors/index.js";

export declare namespace SkyvernClient {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class SkyvernClient {
    protected readonly _options: SkyvernClient.Options;
    protected _scripts: Scripts | undefined;

    constructor(_options: SkyvernClient.Options = {}) {
        this._options = {
            ..._options,
            headers: mergeHeaders(
                {
                    "x-api-key": _options?.apiKey,
                    "X-Fern-Language": "JavaScript",
                    "X-Fern-SDK-Name": "@skyvern/client",
                    "X-Fern-SDK-Version": "0.2.21",
                    "User-Agent": "@skyvern/client/0.2.21",
                    "X-Fern-Runtime": core.RUNTIME.type,
                    "X-Fern-Runtime-Version": core.RUNTIME.version,
                },
                _options?.headers,
            ),
        };
    }

    public get scripts(): Scripts {
        return (this._scripts ??= new Scripts(this._options));
    }

    /**
     * Run a task
     *
     * @param {Skyvern.RunTaskRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.BadRequestError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.runTask({
     *         "x-user-agent": "x-user-agent",
     *         body: {
     *             prompt: "Find the top 3 posts on Hacker News."
     *         }
     *     })
     */
    public runTask(
        request: Skyvern.RunTaskRequest,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.TaskRunResponse> {
        return core.HttpResponsePromise.fromPromise(this.__runTask(request, requestOptions));
    }

    private async __runTask(
        request: Skyvern.RunTaskRequest,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.TaskRunResponse>> {
        const { "x-user-agent": userAgent, body: _body } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-user-agent": userAgent != null ? userAgent : undefined,
                "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                "v1/run/tasks",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.TaskRunResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Skyvern.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/run/tasks.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Run a workflow
     *
     * @param {Skyvern.RunWorkflowRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.BadRequestError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.runWorkflow({
     *         "x-max-steps-override": 1,
     *         "x-user-agent": "x-user-agent",
     *         template: true,
     *         body: {
     *             workflow_id: "wpid_123"
     *         }
     *     })
     */
    public runWorkflow(
        request: Skyvern.RunWorkflowRequest,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.WorkflowRunResponse> {
        return core.HttpResponsePromise.fromPromise(this.__runWorkflow(request, requestOptions));
    }

    private async __runWorkflow(
        request: Skyvern.RunWorkflowRequest,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.WorkflowRunResponse>> {
        const { template, "x-max-steps-override": maxStepsOverride, "x-user-agent": userAgent, body: _body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (template != null) {
            _queryParams.template = template.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-max-steps-override": maxStepsOverride != null ? maxStepsOverride.toString() : undefined,
                "x-user-agent": userAgent != null ? userAgent : undefined,
                "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                "v1/run/workflows",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.WorkflowRunResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Skyvern.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/run/workflows.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get run information (task run, workflow run)
     *
     * @param {string} runId - The id of the task run or the workflow run.
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.NotFoundError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getRun("tsk_123")
     */
    public getRun(
        runId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.GetRunResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getRun(runId, requestOptions));
    }

    private async __getRun(
        runId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.GetRunResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                `v1/runs/${core.url.encodePathParam(runId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.GetRunResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyvern.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/runs/{run_id}.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Cancel a run (task or workflow)
     *
     * @param {string} runId - The id of the task run or the workflow run to cancel.
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.cancelRun("run_id")
     */
    public cancelRun(runId: string, requestOptions?: SkyvernClient.RequestOptions): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__cancelRun(runId, requestOptions));
    }

    private async __cancelRun(
        runId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                `v1/runs/${core.url.encodePathParam(runId)}/cancel`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/runs/{run_id}/cancel.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get all workflows with the latest version for the organization.
     *
     * Search semantics:
     * - If `search_key` is provided, its value is used as a unified search term for both
     *   `workflows.title` and workflow parameter metadata (key, description, and default_value for
     *   `WorkflowParameterModel`).
     * - Falls back to deprecated `title` (title-only search) if `search_key` is not provided.
     * - Parameter metadata search excludes soft-deleted parameter rows across all parameter tables.
     *
     * @param {Skyvern.GetWorkflowsRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getWorkflows({
     *         page: 1,
     *         page_size: 1,
     *         only_saved_tasks: true,
     *         only_workflows: true,
     *         search_key: "search_key",
     *         title: "title",
     *         template: true
     *     })
     */
    public getWorkflows(
        request: Skyvern.GetWorkflowsRequest = {},
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.Workflow[]> {
        return core.HttpResponsePromise.fromPromise(this.__getWorkflows(request, requestOptions));
    }

    private async __getWorkflows(
        request: Skyvern.GetWorkflowsRequest = {},
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.Workflow[]>> {
        const {
            page,
            page_size: pageSize,
            only_saved_tasks: onlySavedTasks,
            only_workflows: onlyWorkflows,
            search_key: searchKey,
            title,
            template,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (page != null) {
            _queryParams.page = page.toString();
        }

        if (pageSize != null) {
            _queryParams.page_size = pageSize.toString();
        }

        if (onlySavedTasks != null) {
            _queryParams.only_saved_tasks = onlySavedTasks.toString();
        }

        if (onlyWorkflows != null) {
            _queryParams.only_workflows = onlyWorkflows.toString();
        }

        if (searchKey != null) {
            _queryParams.search_key = searchKey;
        }

        if (title != null) {
            _queryParams.title = title;
        }

        if (template != null) {
            _queryParams.template = template.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                "v1/workflows",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.Workflow[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/workflows.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a new workflow
     *
     * @param {Skyvern.WorkflowRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.createWorkflow({})
     */
    public createWorkflow(
        request: Skyvern.WorkflowRequest,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.Workflow> {
        return core.HttpResponsePromise.fromPromise(this.__createWorkflow(request, requestOptions));
    }

    private async __createWorkflow(
        request: Skyvern.WorkflowRequest,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.Workflow>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                "v1/workflows",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.Workflow, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/workflows.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Update a workflow
     *
     * @param {string} workflowId - The ID of the workflow to update. Workflow ID starts with `wpid_`.
     * @param {Skyvern.WorkflowRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.updateWorkflow("wpid_123", {})
     */
    public updateWorkflow(
        workflowId: string,
        request: Skyvern.WorkflowRequest,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.Workflow> {
        return core.HttpResponsePromise.fromPromise(this.__updateWorkflow(workflowId, request, requestOptions));
    }

    private async __updateWorkflow(
        workflowId: string,
        request: Skyvern.WorkflowRequest,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.Workflow>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                `v1/workflows/${core.url.encodePathParam(workflowId)}`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.Workflow, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/workflows/{workflow_id}.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Delete a workflow
     *
     * @param {string} workflowId - The ID of the workflow to delete. Workflow ID starts with `wpid_`.
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.deleteWorkflow("wpid_123")
     */
    public deleteWorkflow(
        workflowId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__deleteWorkflow(workflowId, requestOptions));
    }

    private async __deleteWorkflow(
        workflowId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                `v1/workflows/${core.url.encodePathParam(workflowId)}/delete`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError(
                    "Timeout exceeded when calling POST /v1/workflows/{workflow_id}/delete.",
                );
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get an artifact
     *
     * @param {string} artifactId
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.NotFoundError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getArtifact("artifact_id")
     */
    public getArtifact(
        artifactId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.Artifact> {
        return core.HttpResponsePromise.fromPromise(this.__getArtifact(artifactId, requestOptions));
    }

    private async __getArtifact(
        artifactId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.Artifact>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                `v1/artifacts/${core.url.encodePathParam(artifactId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.Artifact, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyvern.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/artifacts/{artifact_id}.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get artifacts for a run
     *
     * @param {string} runId - The id of the task run or the workflow run.
     * @param {Skyvern.GetRunArtifactsRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getRunArtifacts("run_id")
     */
    public getRunArtifacts(
        runId: string,
        request: Skyvern.GetRunArtifactsRequest = {},
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.Artifact[]> {
        return core.HttpResponsePromise.fromPromise(this.__getRunArtifacts(runId, request, requestOptions));
    }

    private async __getRunArtifacts(
        runId: string,
        request: Skyvern.GetRunArtifactsRequest = {},
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.Artifact[]>> {
        const { artifact_type: artifactType } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (artifactType != null) {
            if (Array.isArray(artifactType)) {
                _queryParams.artifact_type = artifactType.map((item) => item);
            } else {
                _queryParams.artifact_type = artifactType;
            }
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                `v1/runs/${core.url.encodePathParam(runId)}/artifacts`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.Artifact[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/runs/{run_id}/artifacts.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retry sending the webhook for a run
     *
     * @param {string} runId - The id of the task run or the workflow run.
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.retryRunWebhook("tsk_123")
     */
    public retryRunWebhook(
        runId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__retryRunWebhook(runId, requestOptions));
    }

    private async __retryRunWebhook(
        runId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                `v1/runs/${core.url.encodePathParam(runId)}/retry_webhook`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError(
                    "Timeout exceeded when calling POST /v1/runs/{run_id}/retry_webhook.",
                );
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get timeline for a run (workflow run or task_v2 run)
     *
     * @param {string} runId - The id of the workflow run or task_v2 run.
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.BadRequestError}
     * @throws {@link Skyvern.NotFoundError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getRunTimeline("wr_123")
     */
    public getRunTimeline(
        runId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.WorkflowRunTimeline[]> {
        return core.HttpResponsePromise.fromPromise(this.__getRunTimeline(runId, requestOptions));
    }

    private async __getRunTimeline(
        runId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.WorkflowRunTimeline[]>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                `v1/runs/${core.url.encodePathParam(runId)}/timeline`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.WorkflowRunTimeline[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Skyvern.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Skyvern.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/runs/{run_id}/timeline.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get all active browser sessions for the organization
     *
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.ForbiddenError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getBrowserSessions()
     */
    public getBrowserSessions(
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.BrowserSessionResponse[]> {
        return core.HttpResponsePromise.fromPromise(this.__getBrowserSessions(requestOptions));
    }

    private async __getBrowserSessions(
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.BrowserSessionResponse[]>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                "v1/browser_sessions",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.BrowserSessionResponse[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 403:
                    throw new Skyvern.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/browser_sessions.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a browser session that persists across multiple runs
     *
     * @param {Skyvern.CreateBrowserSessionRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.ForbiddenError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.createBrowserSession()
     */
    public createBrowserSession(
        request: Skyvern.CreateBrowserSessionRequest = {},
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.BrowserSessionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createBrowserSession(request, requestOptions));
    }

    private async __createBrowserSession(
        request: Skyvern.CreateBrowserSessionRequest = {},
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.BrowserSessionResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                "v1/browser_sessions",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.BrowserSessionResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 403:
                    throw new Skyvern.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/browser_sessions.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Close a session. Once closed, the session cannot be used again.
     *
     * @param {string} browserSessionId - The ID of the browser session to close. completed_at will be set when the browser session is closed. browser_session_id starts with `pbs_`
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.ForbiddenError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.closeBrowserSession("pbs_123456")
     */
    public closeBrowserSession(
        browserSessionId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__closeBrowserSession(browserSessionId, requestOptions));
    }

    private async __closeBrowserSession(
        browserSessionId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                `v1/browser_sessions/${core.url.encodePathParam(browserSessionId)}/close`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 403:
                    throw new Skyvern.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError(
                    "Timeout exceeded when calling POST /v1/browser_sessions/{browser_session_id}/close.",
                );
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get details about a specific browser session, including the browser address for cdp connection.
     *
     * @param {string} browserSessionId - The ID of the browser session. browser_session_id starts with `pbs_`
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.ForbiddenError}
     * @throws {@link Skyvern.NotFoundError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getBrowserSession("pbs_123456")
     */
    public getBrowserSession(
        browserSessionId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.BrowserSessionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getBrowserSession(browserSessionId, requestOptions));
    }

    private async __getBrowserSession(
        browserSessionId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.BrowserSessionResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                `v1/browser_sessions/${core.url.encodePathParam(browserSessionId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.BrowserSessionResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 403:
                    throw new Skyvern.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Skyvern.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError(
                    "Timeout exceeded when calling GET /v1/browser_sessions/{browser_session_id}.",
                );
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Forward a TOTP (2FA, MFA) email or sms message containing the code to Skyvern. This endpoint stores the code in database so that Skyvern can use it while running tasks/workflows.
     *
     * @param {Skyvern.TotpCodeCreate} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.sendTotpCode({
     *         totp_identifier: "john.doe@example.com",
     *         content: "Hello, your verification code is 123456"
     *     })
     */
    public sendTotpCode(
        request: Skyvern.TotpCodeCreate,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.TotpCode> {
        return core.HttpResponsePromise.fromPromise(this.__sendTotpCode(request, requestOptions));
    }

    private async __sendTotpCode(
        request: Skyvern.TotpCodeCreate,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.TotpCode>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                "v1/credentials/totp",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.TotpCode, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/credentials/totp.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieves a paginated list of credentials for the current organization
     *
     * @param {Skyvern.GetCredentialsRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getCredentials({
     *         page: 1,
     *         page_size: 10
     *     })
     */
    public getCredentials(
        request: Skyvern.GetCredentialsRequest = {},
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.CredentialResponse[]> {
        return core.HttpResponsePromise.fromPromise(this.__getCredentials(request, requestOptions));
    }

    private async __getCredentials(
        request: Skyvern.GetCredentialsRequest = {},
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.CredentialResponse[]>> {
        const { page, page_size: pageSize } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (page != null) {
            _queryParams.page = page.toString();
        }

        if (pageSize != null) {
            _queryParams.page_size = pageSize.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                "v1/credentials",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.CredentialResponse[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/credentials.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Creates a new credential for the current organization
     *
     * @param {Skyvern.CreateCredentialRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.createCredential({
     *         name: "My Credential",
     *         credential_type: "password",
     *         credential: {
     *             password: "securepassword123",
     *             username: "user@example.com",
     *             totp: "JBSWY3DPEHPK3PXP"
     *         }
     *     })
     */
    public createCredential(
        request: Skyvern.CreateCredentialRequest,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.CredentialResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createCredential(request, requestOptions));
    }

    private async __createCredential(
        request: Skyvern.CreateCredentialRequest,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.CredentialResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                "v1/credentials",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.CredentialResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/credentials.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deletes a specific credential by its ID
     *
     * @param {string} credentialId - The unique identifier of the credential to delete
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.deleteCredential("cred_1234567890")
     */
    public deleteCredential(
        credentialId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deleteCredential(credentialId, requestOptions));
    }

    private async __deleteCredential(
        credentialId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                `v1/credentials/${core.url.encodePathParam(credentialId)}/delete`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError(
                    "Timeout exceeded when calling POST /v1/credentials/{credential_id}/delete.",
                );
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieves a specific credential by its ID
     *
     * @param {string} credentialId - The unique identifier of the credential
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getCredential("cred_1234567890")
     */
    public getCredential(
        credentialId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.CredentialResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getCredential(credentialId, requestOptions));
    }

    private async __getCredential(
        credentialId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.CredentialResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                `v1/credentials/${core.url.encodePathParam(credentialId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.CredentialResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError(
                    "Timeout exceeded when calling GET /v1/credentials/{credential_id}.",
                );
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Log in to a website using either credential stored in Skyvern, Bitwarden, 1Password, or Azure Vault
     *
     * @param {Skyvern.LoginRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.login({
     *         credential_type: "skyvern"
     *     })
     */
    public login(
        request: Skyvern.LoginRequest,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.WorkflowRunResponse> {
        return core.HttpResponsePromise.fromPromise(this.__login(request, requestOptions));
    }

    private async __login(
        request: Skyvern.LoginRequest,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.WorkflowRunResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                "v1/run/tasks/login",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.WorkflowRunResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/run/tasks/login.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieves a paginated list of scripts for the current organization
     *
     * @param {Skyvern.GetScriptsRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getScripts({
     *         page: 1,
     *         page_size: 10
     *     })
     */
    public getScripts(
        request: Skyvern.GetScriptsRequest = {},
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.Script[]> {
        return core.HttpResponsePromise.fromPromise(this.__getScripts(request, requestOptions));
    }

    private async __getScripts(
        request: Skyvern.GetScriptsRequest = {},
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.Script[]>> {
        const { page, page_size: pageSize } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (page != null) {
            _queryParams.page = page.toString();
        }

        if (pageSize != null) {
            _queryParams.page_size = pageSize.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                "v1/scripts",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.Script[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/scripts.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a new script with optional files and metadata
     *
     * @param {Skyvern.CreateScriptRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.createScript()
     */
    public createScript(
        request: Skyvern.CreateScriptRequest = {},
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.CreateScriptResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createScript(request, requestOptions));
    }

    private async __createScript(
        request: Skyvern.CreateScriptRequest = {},
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.CreateScriptResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                "v1/scripts",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.CreateScriptResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/scripts.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieves a specific script by its ID
     *
     * @param {string} scriptId - The unique identifier of the script
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.getScript("s_abc123")
     */
    public getScript(
        scriptId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.Script> {
        return core.HttpResponsePromise.fromPromise(this.__getScript(scriptId, requestOptions));
    }

    private async __getScript(
        scriptId: string,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.Script>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                `v1/scripts/${core.url.encodePathParam(scriptId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.Script, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling GET /v1/scripts/{script_id}.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deploy a script with updated files, creating a new version
     *
     * @param {string} scriptId - The unique identifier of the script
     * @param {Skyvern.DeployScriptRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.deployScript("s_abc123", {
     *         files: [{
     *                 path: "src/main.py",
     *                 content: "content"
     *             }]
     *     })
     */
    public deployScript(
        scriptId: string,
        request: Skyvern.DeployScriptRequest,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.CreateScriptResponse> {
        return core.HttpResponsePromise.fromPromise(this.__deployScript(scriptId, request, requestOptions));
    }

    private async __deployScript(
        scriptId: string,
        request: Skyvern.DeployScriptRequest,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.CreateScriptResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                `v1/scripts/${core.url.encodePathParam(scriptId)}/deploy`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.CreateScriptResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError(
                    "Timeout exceeded when calling POST /v1/scripts/{script_id}/deploy.",
                );
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Execute a single SDK action with the specified parameters
     *
     * @param {Skyvern.RunSdkActionRequest} request
     * @param {SkyvernClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyvern.BadRequestError}
     * @throws {@link Skyvern.ForbiddenError}
     * @throws {@link Skyvern.NotFoundError}
     * @throws {@link Skyvern.UnprocessableEntityError}
     *
     * @example
     *     await client.runSdkAction({
     *         "x-user-agent": "x-user-agent",
     *         url: "url",
     *         action: {
     *             type: "ai_click"
     *         }
     *     })
     */
    public runSdkAction(
        request: Skyvern.RunSdkActionRequest,
        requestOptions?: SkyvernClient.RequestOptions,
    ): core.HttpResponsePromise<Skyvern.RunSdkActionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__runSdkAction(request, requestOptions));
    }

    private async __runSdkAction(
        request: Skyvern.RunSdkActionRequest,
        requestOptions?: SkyvernClient.RequestOptions,
    ): Promise<core.WithRawResponse<Skyvern.RunSdkActionResponse>> {
        const { "x-user-agent": userAgent, ..._body } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-user-agent": userAgent != null ? userAgent : undefined,
                "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyvernEnvironment.Cloud,
                "v1/sdk/run_action",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyvern.RunSdkActionResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Skyvern.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Skyvern.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Skyvern.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Skyvern.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyvernError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyvernError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyvernTimeoutError("Timeout exceeded when calling POST /v1/sdk/run_action.");
            case "unknown":
                throw new errors.SkyvernError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }
}
