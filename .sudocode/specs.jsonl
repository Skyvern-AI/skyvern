{"id":"s-j4ju","uuid":"340b6315-ae19-4604-83f4-8d5a0ca2d740","title":"Block-Level Cache Key Templates","file_path":"specs/block_level_cache_key_templates.md","content":"## Overview\nIntroduce optional cache key templating at the workflow block level so that cached code/artifacts can vary per block instance using workflow parameters and prior block outputs. This augments the existing workflow-level cache key without breaking existing scripts.\n\nMy edit\n\n## Goals\n- Allow each block definition to specify an optional `cache_key_template` string that resolves with workflow/block context.\n- Ensure script generation, execution, persistence, and regeneration use the resolved block cache key so multiple variants can coexist.\n- Expose the setting in the workflow editor UI alongside existing cache controls.\n\n## Non-Goals\n- Changing how workflow-level cache keys are defined.\n- Modifying database schema beyond adding the new field to serialized models.\n- Redesigning broader caching invalidation policies.\n\n## Requirements\n### Backend API & Models\n- Extend all block models (`skyvern/forge/sdk/workflow/models/block.py`) to include `cache_key_template: str | None = None`, mirroring `disable_cache`.\n- Surface the field through:\n  - YAML/REST schemas (`skyvern/schemas/workflows.py` and fern/OpenAPI definitions).\n  - Generated client types (Python, TypeScript) and any DTO transforms.\n  - Codegen inputs (`transform_workflow_run_to_code_gen_input`) so regenerated scripts keep templates.\n- Rendering rules for an executing block:\n  1. Render the workflow-level cache key (if present) using existing logic; otherwise fall back to `workflow.workflow_permanent_id`.\n  2. If the block has a `cache_key_template`, render it with a context containing:\n     - Workflow parameters (same as current workflow-level rendering).\n     - `WorkflowRunContext` block metadata and recorded outputs for completed blocks.\n  3. If evaluation succeeds and yields a non-empty string, set `block_cache_key = f\"{base_key}:{rendered_block_key}\"`.\n  4. If rendering fails or produces an empty string, log a warning and fall back to `cache_key or label` (current behaviour) to avoid breaking execution.\n- Update utilities (`_render_template_with_label` and helpers) to provide the enriched context and return both rendered string and context for reuse.\n- Script generation (`generate_script.py`) must emit decorators using the resolved block cache key so cached functions are registered under the new value.\n- Execution helpers in `script_service.py` should request cached functions with the resolved key and store workflow run blocks using that key when creating/updating cached script mappings.\n- Adjust regeneration logic (`_regenerate_script_block_after_ai_fallback`) and `workflow_script_service` retrieval so cached scripts are looked up by the new block key, ensuring per-block variants coexist.\n\n### Frontend\n- Add a text input for \"Cache Key Template\" to block configuration panels next to \"Disable Cache\" for all block types that support caching.\n- Display helper text indicating templates may reference workflow parameters and previous block outputs.\n- Persist the new field through editor state → API payload → save operations.\n- Optionally provide basic validation (e.g., warn if unmatched `{`/`}`) but allow submission to keep backend authoritative.\n\n### Compatibility & Validation\n- Because the new field defaults to `None`, existing workflows/scripts remain valid without migration; ensure serializers handle missing data.\n- Regenerate API clients / fern SDKs so downstream code sees the new property.\n- Validate key length before use; if longer than backend/storage limits (to confirm), consider hashing or truncating with warning.\n- Ensure log messages avoid leaking sensitive template data when render failures occur.\n\n## Testing\n- Unit tests for template rendering covering workflow params, block outputs, fallback cases, and error handling.\n- Integration test: create workflow with multiple blocks using distinct cache key templates, run twice with different parameter values, verify separate cached scripts.\n- Frontend e2e/regression to confirm template field persists and renders in editor.\n\n## Open Questions\n1. Should we hash or otherwise normalize extremely long rendered keys rather than storing raw strings? (Investigate current limits.)\n2. Do we need admin tooling to list block-level cache key variants similar to existing workflow cache key views?\n3. Are there security/data-governance concerns with exposing prior block outputs to templates (e.g., secrets)? Document and mitigate if needed.\n","priority":2,"archived":0,"archived_at":null,"created_at":"2025-11-06 19:30:22","updated_at":"2025-11-06T19:40:45.455Z","parent_id":null,"parent_uuid":null,"relationships":[],"tags":[]}
