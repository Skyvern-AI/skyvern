// This file was auto-generated by Fern from our API Definition.

import * as Skyvern from "../../src/api/index";
import { SkyvernClient } from "../../src/Client";
import { mockServerPool } from "../mock-server/MockServerPool";

describe("Workflows", () => {
    test("getFolders (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                title: "title",
                description: "description",
                folder_id: "folder_id",
                organization_id: "organization_id",
                workflow_count: 1,
                created_at: "2024-01-15T09:30:00Z",
                modified_at: "2024-01-15T09:30:00Z",
            },
        ];
        server.mockEndpoint().get("/v1/folders").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.workflows.getFolders({
            page: 1,
            page_size: 1,
            search: "search",
        });
        expect(response).toEqual([
            {
                title: "title",
                description: "description",
                folder_id: "folder_id",
                organization_id: "organization_id",
                workflow_count: 1,
                created_at: "2024-01-15T09:30:00Z",
                modified_at: "2024-01-15T09:30:00Z",
            },
        ]);
    });

    test("getFolders (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/v1/folders").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.workflows.getFolders();
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("createFolder (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { title: "title" };
        const rawResponseBody = {
            title: "title",
            description: "description",
            folder_id: "folder_id",
            organization_id: "organization_id",
            workflow_count: 1,
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .post("/v1/folders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workflows.createFolder({
            title: "title",
        });
        expect(response).toEqual({
            title: "title",
            description: "description",
            folder_id: "folder_id",
            organization_id: "organization_id",
            workflow_count: 1,
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
        });
    });

    test("createFolder (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { title: "x" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/folders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workflows.createFolder({
                title: "x",
            });
        }).rejects.toThrow(Skyvern.BadRequestError);
    });

    test("createFolder (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { title: "x" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/v1/folders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workflows.createFolder({
                title: "x",
            });
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("getFolder (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            title: "title",
            description: "description",
            folder_id: "folder_id",
            organization_id: "organization_id",
            workflow_count: 1,
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .get("/v1/folders/fld_123")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workflows.getFolder("fld_123");
        expect(response).toEqual({
            title: "title",
            description: "description",
            folder_id: "folder_id",
            organization_id: "organization_id",
            workflow_count: 1,
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
        });
    });

    test("getFolder (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/folders/folder_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workflows.getFolder("folder_id");
        }).rejects.toThrow(Skyvern.NotFoundError);
    });

    test("getFolder (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/folders/folder_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workflows.getFolder("folder_id");
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("updateFolder (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            title: "title",
            description: "description",
            folder_id: "folder_id",
            organization_id: "organization_id",
            workflow_count: 1,
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .put("/v1/folders/fld_123")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workflows.updateFolder("fld_123");
        expect(response).toEqual({
            title: "title",
            description: "description",
            folder_id: "folder_id",
            organization_id: "organization_id",
            workflow_count: 1,
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
        });
    });

    test("updateFolder (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .put("/v1/folders/folder_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workflows.updateFolder("folder_id");
        }).rejects.toThrow(Skyvern.NotFoundError);
    });

    test("updateFolder (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .put("/v1/folders/folder_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workflows.updateFolder("folder_id");
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("deleteFolder (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/v1/folders/fld_123")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workflows.deleteFolder("fld_123", {
            delete_workflows: true,
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("deleteFolder (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/v1/folders/folder_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workflows.deleteFolder("folder_id");
        }).rejects.toThrow(Skyvern.NotFoundError);
    });

    test("deleteFolder (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/v1/folders/folder_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workflows.deleteFolder("folder_id");
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });

    test("updateWorkflowFolder (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            workflow_id: "workflow_id",
            organization_id: "organization_id",
            title: "title",
            workflow_permanent_id: "workflow_permanent_id",
            version: 1,
            is_saved_task: true,
            description: "description",
            workflow_definition: {
                parameters: [
                    {
                        parameter_type: "aws_secret",
                        key: "key",
                        aws_secret_parameter_id: "aws_secret_parameter_id",
                        workflow_id: "workflow_id",
                        aws_key: "aws_key",
                        created_at: "2024-01-15T09:30:00Z",
                        modified_at: "2024-01-15T09:30:00Z",
                    },
                ],
                blocks: [
                    {
                        block_type: "action",
                        label: "label",
                        output_parameter: {
                            key: "key",
                            output_parameter_id: "output_parameter_id",
                            workflow_id: "workflow_id",
                            created_at: "2024-01-15T09:30:00Z",
                            modified_at: "2024-01-15T09:30:00Z",
                        },
                    },
                ],
            },
            proxy_location: "RESIDENTIAL",
            webhook_callback_url: "webhook_callback_url",
            totp_verification_url: "totp_verification_url",
            totp_identifier: "totp_identifier",
            persist_browser_session: true,
            model: { key: "value" },
            status: "published",
            max_screenshot_scrolls: 1,
            extra_http_headers: { key: "value" },
            run_with: "run_with",
            ai_fallback: true,
            cache_key: "cache_key",
            run_sequentially: true,
            sequential_key: "sequential_key",
            folder_id: "folder_id",
            import_error: "import_error",
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
            deleted_at: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .put("/v1/workflows/wpid_123/folder")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workflows.updateWorkflowFolder("wpid_123");
        expect(response).toEqual({
            workflow_id: "workflow_id",
            organization_id: "organization_id",
            title: "title",
            workflow_permanent_id: "workflow_permanent_id",
            version: 1,
            is_saved_task: true,
            description: "description",
            workflow_definition: {
                parameters: [
                    {
                        parameter_type: "aws_secret",
                        key: "key",
                        aws_secret_parameter_id: "aws_secret_parameter_id",
                        workflow_id: "workflow_id",
                        aws_key: "aws_key",
                        created_at: "2024-01-15T09:30:00Z",
                        modified_at: "2024-01-15T09:30:00Z",
                    },
                ],
                blocks: [
                    {
                        block_type: "action",
                        label: "label",
                        output_parameter: {
                            key: "key",
                            output_parameter_id: "output_parameter_id",
                            workflow_id: "workflow_id",
                            created_at: "2024-01-15T09:30:00Z",
                            modified_at: "2024-01-15T09:30:00Z",
                        },
                    },
                ],
            },
            proxy_location: "RESIDENTIAL",
            webhook_callback_url: "webhook_callback_url",
            totp_verification_url: "totp_verification_url",
            totp_identifier: "totp_identifier",
            persist_browser_session: true,
            model: {
                key: "value",
            },
            status: "published",
            max_screenshot_scrolls: 1,
            extra_http_headers: {
                key: "value",
            },
            run_with: "run_with",
            ai_fallback: true,
            cache_key: "cache_key",
            run_sequentially: true,
            sequential_key: "sequential_key",
            folder_id: "folder_id",
            import_error: "import_error",
            created_at: "2024-01-15T09:30:00Z",
            modified_at: "2024-01-15T09:30:00Z",
            deleted_at: "2024-01-15T09:30:00Z",
        });
    });

    test("updateWorkflowFolder (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .put("/v1/workflows/workflow_permanent_id/folder")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workflows.updateWorkflowFolder("workflow_permanent_id");
        }).rejects.toThrow(Skyvern.BadRequestError);
    });

    test("updateWorkflowFolder (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .put("/v1/workflows/workflow_permanent_id/folder")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workflows.updateWorkflowFolder("workflow_permanent_id");
        }).rejects.toThrow(Skyvern.NotFoundError);
    });

    test("updateWorkflowFolder (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SkyvernClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .put("/v1/workflows/workflow_permanent_id/folder")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workflows.updateWorkflowFolder("workflow_permanent_id");
        }).rejects.toThrow(Skyvern.UnprocessableEntityError);
    });
});
