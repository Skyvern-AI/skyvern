// This file was auto-generated by Fern from our API Definition.

import * as Testcharmvision from "./api/index.js";
import { Scripts } from "./api/resources/scripts/client/Client.js";
import type { BaseClientOptions, BaseRequestOptions } from "./BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "./core/headers.js";
import * as core from "./core/index.js";
import * as environments from "./environments.js";
import * as errors from "./errors/index.js";

export declare namespace TestcharmvisionClient {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class TestcharmvisionClient {
    protected readonly _options: TestcharmvisionClient.Options;
    protected _scripts: Scripts | undefined;

    constructor(_options: TestcharmvisionClient.Options = {}) {
        this._options = {
            ..._options,
            headers: mergeHeaders(
                {
                    "x-api-key": _options?.apiKey,
                    "X-Fern-Language": "JavaScript",
                    "X-Fern-SDK-Name": "@testcharmvision/client",
                    "X-Fern-SDK-Version": "1.0.13",
                    "User-Agent": "@testcharmvision/client/1.0.13",
                    "X-Fern-Runtime": core.RUNTIME.type,
                    "X-Fern-Runtime-Version": core.RUNTIME.version,
                },
                _options?.headers,
            ),
        };
    }

    public get scripts(): Scripts {
        return (this._scripts ??= new Scripts(this._options));
    }

    /**
     * Run a task
     *
     * @param {Testcharmvision.RunTaskRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.BadRequestError}
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.runTask({
     *         "x-user-agent": "x-user-agent",
     *         body: {
     *             prompt: "Find the top 3 posts on Hacker News."
     *         }
     *     })
     */
    public runTask(
        request: Testcharmvision.RunTaskRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.TaskRunResponse> {
        return core.HttpResponsePromise.fromPromise(this.__runTask(request, requestOptions));
    }

    private async __runTask(
        request: Testcharmvision.RunTaskRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.TaskRunResponse>> {
        const { "x-user-agent": userAgent, body: _body } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-user-agent": userAgent != null ? userAgent : undefined,
                "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "v1/run/tasks",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.TaskRunResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Testcharmvision.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling POST /v1/run/tasks.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Run a workflow
     *
     * @param {Testcharmvision.RunWorkflowRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.BadRequestError}
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.runWorkflow({
     *         "x-max-steps-override": 1,
     *         "x-user-agent": "x-user-agent",
     *         template: true,
     *         body: {
     *             workflow_id: "wpid_123"
     *         }
     *     })
     */
    public runWorkflow(
        request: Testcharmvision.RunWorkflowRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.WorkflowRunResponse> {
        return core.HttpResponsePromise.fromPromise(this.__runWorkflow(request, requestOptions));
    }

    private async __runWorkflow(
        request: Testcharmvision.RunWorkflowRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.WorkflowRunResponse>> {
        const { template, "x-max-steps-override": maxStepsOverride, "x-user-agent": userAgent, body: _body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (template != null) {
            _queryParams.template = template.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-max-steps-override": maxStepsOverride != null ? maxStepsOverride.toString() : undefined,
                "x-user-agent": userAgent != null ? userAgent : undefined,
                "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "v1/run/workflows",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.WorkflowRunResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Testcharmvision.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling POST /v1/run/workflows.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get run information (task run, workflow run)
     *
     * @param {string} runId - The id of the task run or the workflow run.
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.NotFoundError}
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.getRun("tsk_123")
     */
    public getRun(
        runId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.GetRunResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getRun(runId, requestOptions));
    }

    private async __getRun(
        runId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.GetRunResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                `v1/runs/${core.url.encodePathParam(runId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.GetRunResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Testcharmvision.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling GET /v1/runs/{run_id}.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Cancel a run (task or workflow)
     *
     * @param {string} runId - The id of the task run or the workflow run to cancel.
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.cancelRun("run_id")
     */
    public cancelRun(runId: string, requestOptions?: TestcharmvisionClient.RequestOptions): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__cancelRun(runId, requestOptions));
    }

    private async __cancelRun(
        runId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                `v1/runs/${core.url.encodePathParam(runId)}/cancel`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling POST /v1/runs/{run_id}/cancel.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get all workflows with the latest version for the organization.
     *
     * Search semantics:
     * - If `search_key` is provided, its value is used as a unified search term for
     *   `workflows.title`, `folders.title`, and workflow parameter metadata (key, description, and default_value for
     *   `WorkflowParameterModel`).
     * - Falls back to deprecated `title` (title-only search) if `search_key` is not provided.
     * - Parameter metadata search excludes soft-deleted parameter rows across all parameter tables.
     *
     * @param {Testcharmvision.GetWorkflowsRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.getWorkflows({
     *         page: 1,
     *         page_size: 1,
     *         only_saved_tasks: true,
     *         only_workflows: true,
     *         only_templates: true,
     *         search_key: "search_key",
     *         title: "title",
     *         folder_id: "folder_id",
     *         template: true
     *     })
     */
    public getWorkflows(
        request: Testcharmvision.GetWorkflowsRequest = {},
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.Workflow[]> {
        return core.HttpResponsePromise.fromPromise(this.__getWorkflows(request, requestOptions));
    }

    private async __getWorkflows(
        request: Testcharmvision.GetWorkflowsRequest = {},
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.Workflow[]>> {
        const {
            page,
            page_size: pageSize,
            only_saved_tasks: onlySavedTasks,
            only_workflows: onlyWorkflows,
            only_templates: onlyTemplates,
            search_key: searchKey,
            title,
            folder_id: folderId,
            status,
            template,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (page != null) {
            _queryParams.page = page.toString();
        }

        if (pageSize != null) {
            _queryParams.page_size = pageSize.toString();
        }

        if (onlySavedTasks != null) {
            _queryParams.only_saved_tasks = onlySavedTasks.toString();
        }

        if (onlyWorkflows != null) {
            _queryParams.only_workflows = onlyWorkflows.toString();
        }

        if (onlyTemplates != null) {
            _queryParams.only_templates = onlyTemplates.toString();
        }

        if (searchKey != null) {
            _queryParams.search_key = searchKey;
        }

        if (title != null) {
            _queryParams.title = title;
        }

        if (folderId != null) {
            _queryParams.folder_id = folderId;
        }

        if (status != null) {
            if (Array.isArray(status)) {
                _queryParams.status = status.map((item) => item);
            } else {
                _queryParams.status = status;
            }
        }

        if (template != null) {
            _queryParams.template = template.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "v1/workflows",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.Workflow[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling GET /v1/workflows.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a new workflow
     *
     * @param {Testcharmvision.CreateWorkflowRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.createWorkflow({
     *         folder_id: "folder_id",
     *         body: {}
     *     })
     */
    public createWorkflow(
        request: Testcharmvision.CreateWorkflowRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.Workflow> {
        return core.HttpResponsePromise.fromPromise(this.__createWorkflow(request, requestOptions));
    }

    private async __createWorkflow(
        request: Testcharmvision.CreateWorkflowRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.Workflow>> {
        const { folder_id: folderId, body: _body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (folderId != null) {
            _queryParams.folder_id = folderId;
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "v1/workflows",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.Workflow, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling POST /v1/workflows.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Update a workflow
     *
     * @param {string} workflowId - The ID of the workflow to update. Workflow ID starts with `wpid_`.
     * @param {Testcharmvision.WorkflowRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.updateWorkflow("wpid_123", {})
     */
    public updateWorkflow(
        workflowId: string,
        request: Testcharmvision.WorkflowRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.Workflow> {
        return core.HttpResponsePromise.fromPromise(this.__updateWorkflow(workflowId, request, requestOptions));
    }

    private async __updateWorkflow(
        workflowId: string,
        request: Testcharmvision.WorkflowRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.Workflow>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                `v1/workflows/${core.url.encodePathParam(workflowId)}`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.Workflow, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling POST /v1/workflows/{workflow_id}.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Delete a workflow
     *
     * @param {string} workflowId - The ID of the workflow to delete. Workflow ID starts with `wpid_`.
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.deleteWorkflow("wpid_123")
     */
    public deleteWorkflow(
        workflowId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__deleteWorkflow(workflowId, requestOptions));
    }

    private async __deleteWorkflow(
        workflowId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                `v1/workflows/${core.url.encodePathParam(workflowId)}/delete`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError(
                    "Timeout exceeded when calling POST /v1/workflows/{workflow_id}/delete.",
                );
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get an artifact
     *
     * @param {string} artifactId
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.NotFoundError}
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.getArtifact("artifact_id")
     */
    public getArtifact(
        artifactId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.Artifact> {
        return core.HttpResponsePromise.fromPromise(this.__getArtifact(artifactId, requestOptions));
    }

    private async __getArtifact(
        artifactId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.Artifact>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                `v1/artifacts/${core.url.encodePathParam(artifactId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.Artifact, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Testcharmvision.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling GET /v1/artifacts/{artifact_id}.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get artifacts for a run
     *
     * @param {string} runId - The id of the task run or the workflow run.
     * @param {Testcharmvision.GetRunArtifactsRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.getRunArtifacts("run_id")
     */
    public getRunArtifacts(
        runId: string,
        request: Testcharmvision.GetRunArtifactsRequest = {},
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.Artifact[]> {
        return core.HttpResponsePromise.fromPromise(this.__getRunArtifacts(runId, request, requestOptions));
    }

    private async __getRunArtifacts(
        runId: string,
        request: Testcharmvision.GetRunArtifactsRequest = {},
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.Artifact[]>> {
        const { artifact_type: artifactType } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (artifactType != null) {
            if (Array.isArray(artifactType)) {
                _queryParams.artifact_type = artifactType.map((item) => item);
            } else {
                _queryParams.artifact_type = artifactType;
            }
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                `v1/runs/${core.url.encodePathParam(runId)}/artifacts`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.Artifact[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling GET /v1/runs/{run_id}/artifacts.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retry sending the webhook for a run
     *
     * @param {string} runId - The id of the task run or the workflow run.
     * @param {Testcharmvision.RetryRunWebhookRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.retryRunWebhook("tsk_123")
     */
    public retryRunWebhook(
        runId: string,
        request?: Testcharmvision.RetryRunWebhookRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__retryRunWebhook(runId, request, requestOptions));
    }

    private async __retryRunWebhook(
        runId: string,
        request?: Testcharmvision.RetryRunWebhookRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                `v1/runs/${core.url.encodePathParam(runId)}/retry_webhook`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request != null ? request : undefined,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError(
                    "Timeout exceeded when calling POST /v1/runs/{run_id}/retry_webhook.",
                );
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get timeline for a run (workflow run or task_v2 run)
     *
     * @param {string} runId - The id of the workflow run or task_v2 run.
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.BadRequestError}
     * @throws {@link Testcharmvision.NotFoundError}
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.getRunTimeline("wr_123")
     */
    public getRunTimeline(
        runId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.WorkflowRunTimeline[]> {
        return core.HttpResponsePromise.fromPromise(this.__getRunTimeline(runId, requestOptions));
    }

    private async __getRunTimeline(
        runId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.WorkflowRunTimeline[]>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                `v1/runs/${core.url.encodePathParam(runId)}/timeline`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.WorkflowRunTimeline[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Testcharmvision.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Testcharmvision.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling GET /v1/runs/{run_id}/timeline.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} workflowPermanentId
     * @param {Testcharmvision.GetWorkflowRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.getWorkflow("workflow_permanent_id", {
     *         version: 1,
     *         template: true
     *     })
     */
    public getWorkflow(
        workflowPermanentId: string,
        request: Testcharmvision.GetWorkflowRequest = {},
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.Workflow> {
        return core.HttpResponsePromise.fromPromise(this.__getWorkflow(workflowPermanentId, request, requestOptions));
    }

    private async __getWorkflow(
        workflowPermanentId: string,
        request: Testcharmvision.GetWorkflowRequest = {},
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.Workflow>> {
        const { version, template } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (version != null) {
            _queryParams.version = version.toString();
        }

        if (template != null) {
            _queryParams.template = template.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                `v1/workflows/${core.url.encodePathParam(workflowPermanentId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.Workflow, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError(
                    "Timeout exceeded when calling GET /v1/workflows/{workflow_permanent_id}.",
                );
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get all versions of a workflow by its permanent ID.
     *
     * @param {string} workflowPermanentId
     * @param {Testcharmvision.GetWorkflowVersionsRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.getWorkflowVersions("workflow_permanent_id", {
     *         template: true
     *     })
     */
    public getWorkflowVersions(
        workflowPermanentId: string,
        request: Testcharmvision.GetWorkflowVersionsRequest = {},
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.Workflow[]> {
        return core.HttpResponsePromise.fromPromise(
            this.__getWorkflowVersions(workflowPermanentId, request, requestOptions),
        );
    }

    private async __getWorkflowVersions(
        workflowPermanentId: string,
        request: Testcharmvision.GetWorkflowVersionsRequest = {},
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.Workflow[]>> {
        const { template } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (template != null) {
            _queryParams.template = template.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                `v1/workflows/${core.url.encodePathParam(workflowPermanentId)}/versions`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.Workflow[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError(
                    "Timeout exceeded when calling GET /v1/workflows/{workflow_permanent_id}/versions.",
                );
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Testcharmvision.BodyUploadFileV1UploadFilePost} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     import { createReadStream } from "fs";
     *     await client.uploadFile({
     *         file: fs.createReadStream("/path/to/your/file")
     *     })
     */
    public uploadFile(
        request: Testcharmvision.BodyUploadFileV1UploadFilePost,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.UploadFileResponse> {
        return core.HttpResponsePromise.fromPromise(this.__uploadFile(request, requestOptions));
    }

    private async __uploadFile(
        request: Testcharmvision.BodyUploadFileV1UploadFilePost,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.UploadFileResponse>> {
        const _request = await core.newFormData();
        await _request.appendFile("file", request.file);
        const _maybeEncodedRequest = await _request.getRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey,
                ..._maybeEncodedRequest.headers,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "v1/upload_file",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.UploadFileResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling POST /v1/upload_file.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get all browser profiles for the organization
     *
     * @param {Testcharmvision.ListBrowserProfilesRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.listBrowserProfiles({
     *         include_deleted: true
     *     })
     */
    public listBrowserProfiles(
        request: Testcharmvision.ListBrowserProfilesRequest = {},
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.BrowserProfile[]> {
        return core.HttpResponsePromise.fromPromise(this.__listBrowserProfiles(request, requestOptions));
    }

    private async __listBrowserProfiles(
        request: Testcharmvision.ListBrowserProfilesRequest = {},
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.BrowserProfile[]>> {
        const { include_deleted: includeDeleted } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (includeDeleted != null) {
            _queryParams.include_deleted = includeDeleted.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "v1/browser_profiles",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.BrowserProfile[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling GET /v1/browser_profiles.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a browser profile from a persistent browser session or workflow run.
     *
     * @param {Testcharmvision.CreateBrowserProfileRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.BadRequestError}
     * @throws {@link Testcharmvision.ConflictError}
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.createBrowserProfile({
     *         name: "name"
     *     })
     */
    public createBrowserProfile(
        request: Testcharmvision.CreateBrowserProfileRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.BrowserProfile> {
        return core.HttpResponsePromise.fromPromise(this.__createBrowserProfile(request, requestOptions));
    }

    private async __createBrowserProfile(
        request: Testcharmvision.CreateBrowserProfileRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.BrowserProfile>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "v1/browser_profiles",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.BrowserProfile, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Testcharmvision.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Testcharmvision.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling POST /v1/browser_profiles.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get a specific browser profile by ID
     *
     * @param {string} profileId - The ID of the browser profile. browser_profile_id starts with `bp_`
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.NotFoundError}
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.getBrowserProfile("bp_123456")
     */
    public getBrowserProfile(
        profileId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.BrowserProfile> {
        return core.HttpResponsePromise.fromPromise(this.__getBrowserProfile(profileId, requestOptions));
    }

    private async __getBrowserProfile(
        profileId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.BrowserProfile>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                `v1/browser_profiles/${core.url.encodePathParam(profileId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.BrowserProfile, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Testcharmvision.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError(
                    "Timeout exceeded when calling GET /v1/browser_profiles/{profile_id}.",
                );
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Delete a browser profile (soft delete)
     *
     * @param {string} profileId - The ID of the browser profile to delete. browser_profile_id starts with `bp_`
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.NotFoundError}
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.deleteBrowserProfile("bp_123456")
     */
    public deleteBrowserProfile(
        profileId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deleteBrowserProfile(profileId, requestOptions));
    }

    private async __deleteBrowserProfile(
        profileId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                `v1/browser_profiles/${core.url.encodePathParam(profileId)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Testcharmvision.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError(
                    "Timeout exceeded when calling DELETE /v1/browser_profiles/{profile_id}.",
                );
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get all active browser sessions for the organization
     *
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.ForbiddenError}
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.getBrowserSessions()
     */
    public getBrowserSessions(
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.BrowserSessionResponse[]> {
        return core.HttpResponsePromise.fromPromise(this.__getBrowserSessions(requestOptions));
    }

    private async __getBrowserSessions(
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.BrowserSessionResponse[]>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "v1/browser_sessions",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.BrowserSessionResponse[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 403:
                    throw new Testcharmvision.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling GET /v1/browser_sessions.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a browser session that persists across multiple runs
     *
     * @param {Testcharmvision.CreateBrowserSessionRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.ForbiddenError}
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.createBrowserSession()
     */
    public createBrowserSession(
        request: Testcharmvision.CreateBrowserSessionRequest = {},
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.BrowserSessionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createBrowserSession(request, requestOptions));
    }

    private async __createBrowserSession(
        request: Testcharmvision.CreateBrowserSessionRequest = {},
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.BrowserSessionResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "v1/browser_sessions",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.BrowserSessionResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 403:
                    throw new Testcharmvision.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling POST /v1/browser_sessions.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Close a session. Once closed, the session cannot be used again.
     *
     * @param {string} browserSessionId - The ID of the browser session to close. completed_at will be set when the browser session is closed. browser_session_id starts with `pbs_`
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.ForbiddenError}
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.closeBrowserSession("pbs_123456")
     */
    public closeBrowserSession(
        browserSessionId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__closeBrowserSession(browserSessionId, requestOptions));
    }

    private async __closeBrowserSession(
        browserSessionId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                `v1/browser_sessions/${core.url.encodePathParam(browserSessionId)}/close`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 403:
                    throw new Testcharmvision.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError(
                    "Timeout exceeded when calling POST /v1/browser_sessions/{browser_session_id}/close.",
                );
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get details about a specific browser session, including the browser address for cdp connection.
     *
     * @param {string} browserSessionId - The ID of the browser session. browser_session_id starts with `pbs_`
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.ForbiddenError}
     * @throws {@link Testcharmvision.NotFoundError}
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.getBrowserSession("pbs_123456")
     */
    public getBrowserSession(
        browserSessionId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.BrowserSessionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getBrowserSession(browserSessionId, requestOptions));
    }

    private async __getBrowserSession(
        browserSessionId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.BrowserSessionResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                `v1/browser_sessions/${core.url.encodePathParam(browserSessionId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.BrowserSessionResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 403:
                    throw new Testcharmvision.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Testcharmvision.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError(
                    "Timeout exceeded when calling GET /v1/browser_sessions/{browser_session_id}.",
                );
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Forward a TOTP (2FA, MFA) email or sms message containing the code to Testcharmvision. This endpoint stores the code in database so that Testcharmvision can use it while running tasks/workflows.
     *
     * @param {Testcharmvision.TotpCodeCreate} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.sendTotpCode({
     *         totp_identifier: "john.doe@example.com",
     *         content: "Hello, your verification code is 123456"
     *     })
     */
    public sendTotpCode(
        request: Testcharmvision.TotpCodeCreate,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.TotpCode> {
        return core.HttpResponsePromise.fromPromise(this.__sendTotpCode(request, requestOptions));
    }

    private async __sendTotpCode(
        request: Testcharmvision.TotpCodeCreate,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.TotpCode>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "v1/credentials/totp",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.TotpCode, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling POST /v1/credentials/totp.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieves a paginated list of credentials for the current organization
     *
     * @param {Testcharmvision.GetCredentialsRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.getCredentials({
     *         page: 1,
     *         page_size: 10
     *     })
     */
    public getCredentials(
        request: Testcharmvision.GetCredentialsRequest = {},
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.CredentialResponse[]> {
        return core.HttpResponsePromise.fromPromise(this.__getCredentials(request, requestOptions));
    }

    private async __getCredentials(
        request: Testcharmvision.GetCredentialsRequest = {},
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.CredentialResponse[]>> {
        const { page, page_size: pageSize } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (page != null) {
            _queryParams.page = page.toString();
        }

        if (pageSize != null) {
            _queryParams.page_size = pageSize.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "v1/credentials",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.CredentialResponse[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling GET /v1/credentials.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Creates a new credential for the current organization
     *
     * @param {Testcharmvision.CreateCredentialRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.createCredential({
     *         name: "My Credential",
     *         credential_type: "password",
     *         credential: {
     *             password: "securepassword123",
     *             username: "user@example.com",
     *             totp: "JBSWY3DPEHPK3PXP"
     *         }
     *     })
     */
    public createCredential(
        request: Testcharmvision.CreateCredentialRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.CredentialResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createCredential(request, requestOptions));
    }

    private async __createCredential(
        request: Testcharmvision.CreateCredentialRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.CredentialResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "v1/credentials",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.CredentialResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling POST /v1/credentials.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deletes a specific credential by its ID
     *
     * @param {string} credentialId - The unique identifier of the credential to delete
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.deleteCredential("cred_1234567890")
     */
    public deleteCredential(
        credentialId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deleteCredential(credentialId, requestOptions));
    }

    private async __deleteCredential(
        credentialId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                `v1/credentials/${core.url.encodePathParam(credentialId)}/delete`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError(
                    "Timeout exceeded when calling POST /v1/credentials/{credential_id}/delete.",
                );
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieves a specific credential by its ID
     *
     * @param {string} credentialId - The unique identifier of the credential
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.getCredential("cred_1234567890")
     */
    public getCredential(
        credentialId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.CredentialResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getCredential(credentialId, requestOptions));
    }

    private async __getCredential(
        credentialId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.CredentialResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                `v1/credentials/${core.url.encodePathParam(credentialId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.CredentialResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError(
                    "Timeout exceeded when calling GET /v1/credentials/{credential_id}.",
                );
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Log in to a website using either credential stored in Testcharmvision, Bitwarden, 1Password, or Azure Vault
     *
     * @param {Testcharmvision.LoginRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.login({
     *         credential_type: "testcharmvision"
     *     })
     */
    public login(
        request: Testcharmvision.LoginRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.WorkflowRunResponse> {
        return core.HttpResponsePromise.fromPromise(this.__login(request, requestOptions));
    }

    private async __login(
        request: Testcharmvision.LoginRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.WorkflowRunResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "v1/run/tasks/login",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.WorkflowRunResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling POST /v1/run/tasks/login.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Download a file from a website by navigating and clicking download buttons
     *
     * @param {Testcharmvision.DownloadFilesRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.downloadFiles({
     *         navigation_goal: "navigation_goal"
     *     })
     */
    public downloadFiles(
        request: Testcharmvision.DownloadFilesRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.WorkflowRunResponse> {
        return core.HttpResponsePromise.fromPromise(this.__downloadFiles(request, requestOptions));
    }

    private async __downloadFiles(
        request: Testcharmvision.DownloadFilesRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.WorkflowRunResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "v1/run/tasks/download_files",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.WorkflowRunResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError(
                    "Timeout exceeded when calling POST /v1/run/tasks/download_files.",
                );
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieves a paginated list of scripts for the current organization
     *
     * @param {Testcharmvision.GetScriptsRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.getScripts({
     *         page: 1,
     *         page_size: 10
     *     })
     */
    public getScripts(
        request: Testcharmvision.GetScriptsRequest = {},
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.Script[]> {
        return core.HttpResponsePromise.fromPromise(this.__getScripts(request, requestOptions));
    }

    private async __getScripts(
        request: Testcharmvision.GetScriptsRequest = {},
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.Script[]>> {
        const { page, page_size: pageSize } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (page != null) {
            _queryParams.page = page.toString();
        }

        if (pageSize != null) {
            _queryParams.page_size = pageSize.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "v1/scripts",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.Script[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling GET /v1/scripts.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a new script with optional files and metadata
     *
     * @param {Testcharmvision.CreateScriptRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.createScript()
     */
    public createScript(
        request: Testcharmvision.CreateScriptRequest = {},
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.CreateScriptResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createScript(request, requestOptions));
    }

    private async __createScript(
        request: Testcharmvision.CreateScriptRequest = {},
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.CreateScriptResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "v1/scripts",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.CreateScriptResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling POST /v1/scripts.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieves a specific script by its ID
     *
     * @param {string} scriptId - The unique identifier of the script
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.getScript("s_abc123")
     */
    public getScript(
        scriptId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.Script> {
        return core.HttpResponsePromise.fromPromise(this.__getScript(scriptId, requestOptions));
    }

    private async __getScript(
        scriptId: string,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.Script>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                `v1/scripts/${core.url.encodePathParam(scriptId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.Script, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling GET /v1/scripts/{script_id}.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deploy a script with updated files, creating a new version
     *
     * @param {string} scriptId - The unique identifier of the script
     * @param {Testcharmvision.DeployScriptRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.deployScript("s_abc123", {
     *         files: [{
     *                 path: "src/main.py",
     *                 content: "content"
     *             }]
     *     })
     */
    public deployScript(
        scriptId: string,
        request: Testcharmvision.DeployScriptRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.CreateScriptResponse> {
        return core.HttpResponsePromise.fromPromise(this.__deployScript(scriptId, request, requestOptions));
    }

    private async __deployScript(
        scriptId: string,
        request: Testcharmvision.DeployScriptRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.CreateScriptResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                `v1/scripts/${core.url.encodePathParam(scriptId)}/deploy`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.CreateScriptResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError(
                    "Timeout exceeded when calling POST /v1/scripts/{script_id}/deploy.",
                );
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Execute a single SDK action with the specified parameters
     *
     * @param {Testcharmvision.RunSdkActionRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.runSdkAction({
     *         url: "url",
     *         action: {
     *             type: "ai_act"
     *         }
     *     })
     */
    public runSdkAction(
        request: Testcharmvision.RunSdkActionRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.RunSdkActionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__runSdkAction(request, requestOptions));
    }

    private async __runSdkAction(
        request: Testcharmvision.RunSdkActionRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.RunSdkActionResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "v1/sdk/run_action",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.RunSdkActionResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling POST /v1/sdk/run_action.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a Stripe Checkout Session for subscribing to a tier.
     *
     * Frontend should redirect the user to the returned URL.
     * After successful checkout, Stripe will send a webhook that we handle
     * to store the subscription and initialize billing state.
     *
     * Returns 400 if org already has an active subscription (use portal instead).
     *
     * @param {Testcharmvision.CheckoutSubscriptionRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.createCheckoutSessionApiV1BillingCheckoutPost({
     *         tier: "free"
     *     })
     */
    public createCheckoutSessionApiV1BillingCheckoutPost(
        request: Testcharmvision.CheckoutSubscriptionRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.CheckoutSessionResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__createCheckoutSessionApiV1BillingCheckoutPost(request, requestOptions),
        );
    }

    private async __createCheckoutSessionApiV1BillingCheckoutPost(
        request: Testcharmvision.CheckoutSubscriptionRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.CheckoutSessionResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "api/v1/billing/checkout",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.CheckoutSessionResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling POST /api/v1/billing/checkout.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a Stripe Customer Portal session for managing subscription.
     *
     * Frontend should redirect the user to the returned URL.
     * The portal allows users to:
     * - Update payment methods
     * - Upgrade/downgrade plans
     * - Cancel subscription
     * - View invoices
     *
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.createPortalSessionApiV1BillingPortalPost()
     */
    public createPortalSessionApiV1BillingPortalPost(
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.PortalSessionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createPortalSessionApiV1BillingPortalPost(requestOptions));
    }

    private async __createPortalSessionApiV1BillingPortalPost(
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.PortalSessionResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "api/v1/billing/portal",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.PortalSessionResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling POST /api/v1/billing/portal.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.getOrganizationBillingApiV1BillingStateGet()
     */
    public getOrganizationBillingApiV1BillingStateGet(
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.BillingStateResponse | undefined> {
        return core.HttpResponsePromise.fromPromise(this.__getOrganizationBillingApiV1BillingStateGet(requestOptions));
    }

    private async __getOrganizationBillingApiV1BillingStateGet(
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.BillingStateResponse | undefined>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "api/v1/billing/state",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Testcharmvision.BillingStateResponse | undefined,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling GET /api/v1/billing/state.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Redirect to Stripe Portal for tier changes.
     * Portal handles proration based on configured settings:
     * - Upgrades: Immediate proration charge
     * - Downgrades: Apply at end of billing period
     *
     * @param {Testcharmvision.ChangeTierRequest} request
     * @param {TestcharmvisionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Testcharmvision.UnprocessableEntityError}
     *
     * @example
     *     await client.changeTierApiV1BillingChangeTierPost({
     *         tier: "free"
     *     })
     */
    public changeTierApiV1BillingChangeTierPost(
        request: Testcharmvision.ChangeTierRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): core.HttpResponsePromise<Testcharmvision.ChangeTierResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__changeTierApiV1BillingChangeTierPost(request, requestOptions),
        );
    }

    private async __changeTierApiV1BillingChangeTierPost(
        request: Testcharmvision.ChangeTierRequest,
        requestOptions?: TestcharmvisionClient.RequestOptions,
    ): Promise<core.WithRawResponse<Testcharmvision.ChangeTierResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.TestcharmvisionEnvironment.Cloud,
                "api/v1/billing/change-tier",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Testcharmvision.ChangeTierResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Testcharmvision.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TestcharmvisionError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TestcharmvisionError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TestcharmvisionTimeoutError("Timeout exceeded when calling POST /api/v1/billing/change-tier.");
            case "unknown":
                throw new errors.TestcharmvisionError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }
}
